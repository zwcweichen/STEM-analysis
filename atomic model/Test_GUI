import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
import io
import traceback
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qtagg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
from matplotlib.widgets import LassoSelector, RectangleSelector
from matplotlib.path import Path

from PyQt6.QtWidgets import (QApplication, QMainWindow, QPushButton, QVBoxLayout, QHBoxLayout,
                           QWidget, QTableView, QHeaderView, QLabel, QComboBox, QFileDialog,
                           QMessageBox, QSplitter, QTabWidget, QGroupBox)
from PyQt6.QtCore import Qt, QAbstractTableModel, QModelIndex
from PyQt6.QtGui import QAction

from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.enum.text import PP_ALIGN


# 用于在QTableView中显示pandas DataFrame的自定义模型
class PandasModel(QAbstractTableModel):
    def __init__(self, data=None):
        super().__init__()
        self._data = pd.DataFrame() if data is None else data

    def rowCount(self, parent=QModelIndex()):
        return self._data.shape[0]

    def columnCount(self, parent=QModelIndex()):
        return self._data.shape[1]

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None

        if role == Qt.ItemDataRole.DisplayRole:
            value = self._data.iloc[index.row(), index.column()]
            # 处理特殊值的显示
            if pd.isna(value):
                return ""
            elif isinstance(value, (float, np.float64)):
                if abs(value) < 0.0001:
                    return f"{value:.4e}"
                else:
                    return f"{value:.4f}"
            else:
                return str(value)

        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                return str(self._data.columns[section])
            else:
                return str(section + 1)
        return None

    def setData(self, data):
        self._data = data
        self.layoutChanged.emit()


# 自定义的Figure Canvas，支持交互式选择
class InteractiveFigureCanvas(FigureCanvas):
    def __init__(self, fig, parent=None):
        super().__init__(fig)
        self.setParent(parent)
        self.figure = fig
        self.selected_points = []
        self.wafer_ids = []
        self.selector = None
        self.callback = None

    def enable_selection(self, mode='rectangle', callback=None):
        """启用选择模式，可以是'rectangle'或'lasso'"""
        if self.figure.axes:
            ax = self.figure.axes[0]
            self.callback = callback

            if mode == 'rectangle':
                self.selector = RectangleSelector(
                    ax, self.on_select, useblit=True,
                    button=[1], minspanx=5, minspany=5,
                    spancoords='pixels', interactive=True
                )
            elif mode == 'lasso':
                self.selector = LassoSelector(
                    ax, self.on_select_lasso, useblit=True
                )

    def disable_selection(self):
        """禁用选择模式"""
        if self.selector:
            self.selector.set_active(False)
            self.selector = None

    def on_select(self, eclick, erelease):
        """矩形选择回调"""
        if not self.figure.axes:
            return

        ax = self.figure.axes[0]
        x1, y1 = eclick.xdata, eclick.ydata
        x2, y2 = erelease.xdata, erelease.ydata

        # 获取所有点的坐标
        for line in ax.get_lines():
            xdata = line.get_xdata()
            ydata = line.get_ydata()

            # 找出在选择区域内的点
            selected_indices = np.where(
                (xdata >= min(x1, x2)) & (xdata <= max(x1, x2)) &
                (ydata >= min(y1, y2)) & (ydata <= max(y1, y2))
            )[0]

            if len(selected_indices) > 0 and self.callback:
                self.callback(selected_indices, line)
                
        # 选择完成后自动禁用选择器
        self.disable_selection()

    def on_select_lasso(self, verts):
        """套索选择回调"""
        if not self.figure.axes:
            return

        ax = self.figure.axes[0]
        path = Path(verts)

        # 获取所有点的坐标
        for line in ax.get_lines():
            xdata = line.get_xdata()
            ydata = line.get_ydata()
            coords = np.column_stack([xdata, ydata])

            # 找出在套索区域内的点
            selected_indices = np.where(path.contains_points(coords))[0]

            if len(selected_indices) > 0 and self.callback:
                self.callback(selected_indices, line)
                
        # 选择完成后自动禁用选择器
        self.disable_selection()


class WaferAnalysisApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("晶圆测量分析工具")
        self.setGeometry(100, 100, 1280, 800)

        # 数据存储
        self.query_data = None
        self.condition_data = None
        self.transformed_data = None
        self.display_data = None  # 用于显示的数据副本，可以排除异常值
        self.wafer_id_col = None
        self.condition_col = None
        self.site_col = None
        self.available_parameters = []
        self.condition_types = []
        self.current_parameter = None
        self.excluded_points = {}  # 存储被排除的点 {parameter: [(condition, wafer_id, site_id), ...]}
        self.temp_selected_points = {}  # 临时存储被选中的点，等待确认
        self.operation_history = []  # 用于存储操作历史，支持撤销功能

        # 设置菜单栏
        self.create_menu_bar()

        # 设置UI
        self.setup_ui()

    def create_menu_bar(self):
        menu_bar = self.menuBar()

        # 文件菜单
        file_menu = menu_bar.addMenu("文件")

        # 打开查询数据
        open_query_action = QAction("打开查询数据", self)
        open_query_action.triggered.connect(self.load_query_data)
        file_menu.addAction(open_query_action)

        # 打开条件数据
        open_cond_action = QAction("打开条件数据", self)
        open_cond_action.triggered.connect(self.load_condition_data)
        file_menu.addAction(open_cond_action)

        file_menu.addSeparator()

        # 导出Excel
        export_excel_action = QAction("导出Excel", self)
        export_excel_action.triggered.connect(self.export_excel)
        file_menu.addAction(export_excel_action)

        # 创建PPT
        create_ppt_action = QAction("创建PPT报告", self)
        create_ppt_action.triggered.connect(self.create_ppt)
        file_menu.addAction(create_ppt_action)

        file_menu.addSeparator()

        # 退出
        exit_action = QAction("退出", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # 数据菜单
        data_menu = menu_bar.addMenu("数据")

        # 处理数据
        process_action = QAction("处理数据", self)
        process_action.triggered.connect(self.process_data)
        data_menu.addAction(process_action)

        # 清除排除点
        clear_exclude_action = QAction("清除排除点", self)
        clear_exclude_action.triggered.connect(self.clear_excluded_points)
        data_menu.addAction(clear_exclude_action)

        # 帮助菜单
        help_menu = menu_bar.addMenu("帮助")

        # 关于
        about_action = QAction("关于", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

    def setup_ui(self):
        # 主布局
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # 顶部控制区域
        top_controls = QWidget()
        top_layout = QHBoxLayout(top_controls)

        # 文件上传区域
        file_group = QGroupBox("数据文件")
        file_layout = QHBoxLayout(file_group)

        self.query_btn = QPushButton("上传查询数据")
        self.condition_btn = QPushButton("上传条件数据")
        self.process_btn = QPushButton("处理数据")

        self.query_btn.clicked.connect(self.load_query_data)
        self.condition_btn.clicked.connect(self.load_condition_data)
        self.process_btn.clicked.connect(self.process_data)

        file_layout.addWidget(self.query_btn)
        file_layout.addWidget(self.condition_btn)
        file_layout.addWidget(self.process_btn)

        # 参数选择区域
        param_group = QGroupBox("参数选择")
        param_layout = QHBoxLayout(param_group)

        param_label = QLabel("选择参数:")
        self.param_combo = QComboBox()
        self.param_combo.currentIndexChanged.connect(self.on_parameter_changed)
        
        param_layout.addWidget(param_label)
        param_layout.addWidget(self.param_combo)

        # 导出区域
        export_group = QGroupBox("导出")
        export_layout = QHBoxLayout(export_group)

        self.export_excel_btn = QPushButton("导出Excel")
        self.export_ppt_btn = QPushButton("创建PPT")
        
        self.export_excel_btn.clicked.connect(self.export_excel)
        self.export_ppt_btn.clicked.connect(self.create_ppt)
        
        export_layout.addWidget(self.export_excel_btn)
        export_layout.addWidget(self.export_ppt_btn)

        # 添加到顶部布局
        top_layout.addWidget(file_group)
        top_layout.addWidget(param_group)
        top_layout.addWidget(export_group)

        # 主分割窗口
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # 左侧数据表格和统计信息
        table_widget = QWidget()
        table_layout = QVBoxLayout(table_widget)
        
        # 添加数据表格和统计信息的垂直分割
        table_splitter = QSplitter(Qt.Orientation.Vertical)
        
        # 上部分：数据表格
        table_upper = QWidget()
        table_upper_layout = QVBoxLayout(table_upper)
        table_label = QLabel("数据表格")
        self.table_view = QTableView()
        self.table_model = PandasModel()
        self.table_view.setModel(self.table_model)
        
        table_upper_layout.addWidget(table_label)
        table_upper_layout.addWidget(self.table_view)
        
        # 下部分：统计信息
        table_lower = QWidget()
        table_lower_layout = QVBoxLayout(table_lower)
        stats_label = QLabel("统计结果")
        self.stats_view = QTableView()
        self.stats_model = PandasModel()
        self.stats_view.setModel(self.stats_model)
        
        table_lower_layout.addWidget(stats_label)
        table_lower_layout.addWidget(self.stats_view)
        
        # 添加到分割器
        table_splitter.addWidget(table_upper)
        table_splitter.addWidget(table_lower)
        table_splitter.setSizes([600, 200])  # 设置初始比例
        
        table_layout.addWidget(table_splitter)
        
        # 右侧图表区域
        plot_widget = QWidget()
        plot_layout = QVBoxLayout(plot_widget)
        
        # 创建选项卡窗口用于Box Plot和QQ Plot
        tab_widget = QTabWidget()
        
        # Box Plot 选项卡
        self.box_tab = QWidget()
        box_layout = QVBoxLayout(self.box_tab)
        
        self.box_fig = Figure(figsize=(5, 4), dpi=100)
        self.box_canvas = InteractiveFigureCanvas(self.box_fig)
        self.box_toolbar = NavigationToolbar(self.box_canvas, self.box_tab)
        
        box_layout.addWidget(self.box_toolbar)
        box_layout.addWidget(self.box_canvas)
        
        # QQ Plot 选项卡
        self.qq_tab = QWidget()
        qq_layout = QVBoxLayout(self.qq_tab)
        
        self.qq_fig = Figure(figsize=(5, 4), dpi=100)
        self.qq_canvas = InteractiveFigureCanvas(self.qq_fig)
        self.qq_toolbar = NavigationToolbar(self.qq_canvas, self.qq_tab)
        
        qq_layout.addWidget(self.qq_toolbar)
        qq_layout.addWidget(self.qq_canvas)
        
        # 添加选项卡
        tab_widget.addTab(self.box_tab, "箱形图")
        tab_widget.addTab(self.qq_tab, "Q-Q图")
        
        plot_layout.addWidget(tab_widget)
        
        # 右下方控制区域
        plot_controls = QWidget()
        plot_controls_layout = QHBoxLayout(plot_controls)
        
        self.rect_select_btn = QPushButton("矩形选择")
        self.lasso_select_btn = QPushButton("套索选择")
        self.confirm_select_btn = QPushButton("确认删除")  # 新增确认删除按钮
        self.clear_select_btn = QPushButton("清除选择")
        self.undo_select_btn = QPushButton("上一步")
        
        self.rect_select_btn.clicked.connect(lambda: self.enable_selection_mode('rectangle'))
        self.lasso_select_btn.clicked.connect(lambda: self.enable_selection_mode('lasso'))
        self.confirm_select_btn.clicked.connect(self.confirm_selection)  # 连接确认删除功能
        self.clear_select_btn.clicked.connect(self.clear_selection)
        self.undo_select_btn.clicked.connect(self.undo_selection)
        
        plot_controls_layout.addWidget(self.rect_select_btn)
        plot_controls_layout.addWidget(self.lasso_select_btn)
        plot_controls_layout.addWidget(self.confirm_select_btn)
        plot_controls_layout.addWidget(self.clear_select_btn)
        plot_controls_layout.addWidget(self.undo_select_btn)
        
        plot_layout.addWidget(plot_controls)
        
        # 添加到分割窗口
        splitter.addWidget(table_widget)
        splitter.addWidget(plot_widget)
        splitter.setSizes([400, 800])  # 设置初始大小比例
        
        # 添加到主布局
        main_layout.addWidget(top_controls)
        main_layout.addWidget(splitter, 1)  # 1表示拉伸因子

        # 初始状态设置
        self.export_excel_btn.setEnabled(False)
        self.export_ppt_btn.setEnabled(False)
        self.param_combo.setEnabled(False)
        self.rect_select_btn.setEnabled(False)
        self.lasso_select_btn.setEnabled(False)
        self.confirm_select_btn.setEnabled(False)  # 初始状态禁用确认按钮
        self.clear_select_btn.setEnabled(False)
        self.undo_select_btn.setEnabled(False)


    def load_query_data(self):
        """加载查询数据文件"""
        file_name, _ = QFileDialog.getOpenFileName(
            self, "选择查询数据文件", "", "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        
        if file_name:
            try:
                if file_name.endswith('.csv'):
                    self.query_data = pd.read_csv(file_name)
                else:
                    self.query_data = pd.read_excel(file_name)
                
                QMessageBox.information(self, "成功", f"已加载查询数据: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"加载数据时出错: {str(e)}")

    def load_condition_data(self):
        """加载条件数据文件"""
        file_name, _ = QFileDialog.getOpenFileName(
            self, "选择条件数据文件", "", "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        
        if file_name:
            try:
                if file_name.endswith('.csv'):
                    self.condition_data = pd.read_csv(file_name)
                else:
                    self.condition_data = pd.read_excel(file_name)
                
                QMessageBox.information(self, "成功", f"已加载条件数据: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"加载数据时出错: {str(e)}")

    def process_data(self):
        """处理数据"""
        if self.query_data is None or self.condition_data is None:
            if self.query_data is None and self.condition_data is None:
                # 如果两个数据都未加载，创建模拟数据
                self.create_sample_data()
            else:
                QMessageBox.warning(self, "警告", "请先加载查询数据和条件数据")
                return
        
        try:
            # 处理数据
            transformed_data, condition_types, measure_parameters, wafer_id_col, condition_col, site_col = self.transform_data()
            
            if transformed_data is not None:
                self.transformed_data = transformed_data
                # 创建一个副本用于图表显示，以便在不改变原始数据的情况下移除异常值
                self.display_data = transformed_data.copy()
                self.condition_types = condition_types
                self.wafer_id_col = wafer_id_col
                self.condition_col = condition_col
                self.site_col = site_col
                
                # 清除排除点和临时选择
                self.excluded_points = {}
                self.temp_selected_points = {}
                # 添加历史操作记录，用于"上一步"功能
                self.operation_history = []
                
                # 更新可用参数
                self.available_parameters = []
                for param in measure_parameters:
                    if param in transformed_data.columns:
                        self.available_parameters.append(param)
                
                if len(self.available_parameters) == 0:
                    # 如果没有找到可用参数，尝试使用非ID和非条件列
                    for col in transformed_data.columns:
                        if "wafer" not in col.lower() and col != condition_col and col != site_col:
                            self.available_parameters.append(col)
                
                # 更新UI
                self.update_parameter_combo()
                self.update_table_view()
                
                # 启用功能按钮
                self.export_excel_btn.setEnabled(True)
                self.export_ppt_btn.setEnabled(True)
                self.param_combo.setEnabled(True)
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                self.clear_select_btn.setEnabled(True)
                self.confirm_select_btn.setEnabled(False)  # 初始没有选择，禁用确认按钮
                self.undo_select_btn.setEnabled(False)  # 初始没有操作，禁用上一步
                
                QMessageBox.information(self, "成功", "数据处理完成")
            else:
                QMessageBox.warning(self, "警告", "数据处理失败")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"处理数据时出错: {str(e)}\n{traceback.format_exc()}")

    def transform_data(self):
        """转换数据，合并查询数据和条件数据，保留Site ID信息"""
        try:
            # 查找查询数据中的Wafer ID列
            wafer_id_query = "Wafer ID" if "Wafer ID" in self.query_data.columns else "WaferID"
            if wafer_id_query not in self.query_data.columns:
                # 寻找可能包含wafer id的列
                for col in self.query_data.columns:
                    if "wafer" in col.lower():
                        wafer_id_query = col
                        break
            
            # 查找条件数据中的WaferID列
            wafer_id_condition = "WaferID" if "WaferID" in self.condition_data.columns else "Wafer ID"
            if wafer_id_condition not in self.condition_data.columns:
                # 寻找可能包含wafer id的列
                for col in self.condition_data.columns:
                    if "wafer" in col.lower():
                        wafer_id_condition = col
                        break
            
            # 查找参数名列、值列和Site ID列
            parameter_col = None
            value_col = None
            site_col = None
            
            for col in self.query_data.columns:
                if "parameter name" in col.lower() or "name" in col.lower():
                    parameter_col = col
                elif "value" in col.lower():
                    value_col = col
                elif "site" in col.lower() and "value" not in col.lower():
                    site_col = col
            
            # 查找条件列
            condition_col = None
            for col in self.condition_data.columns:
                if "condition" in col.lower():
                    condition_col = col
                    break
            
            # 获取条件类型（通常是Baseline和2nd tool）
            if condition_col and condition_col in self.condition_data.columns:
                condition_types = self.condition_data[condition_col].unique()
            else:
                condition_types = ["Baseline", "2nd tool"]
            
            # 获取参数列表
            if parameter_col and parameter_col in self.query_data.columns:
                measure_parameters = self.query_data[parameter_col].unique()
            else:
                measure_parameters = ["Con_M3LA", "Con_M3LB", "Rc_V2v", "LK_M3LA", "LK_M3LB"]
            
            # 合并数据
            merged_data = pd.merge(
                self.query_data,
                self.condition_data,
                left_on=wafer_id_query,
                right_on=wafer_id_condition,
            )
            
            # 使用Site ID创建透视表
            try:
                # 准备包含Site ID的数据转换
                if site_col:
                    # 使用Site ID进行透视
                    pivot_data = merged_data.pivot_table(
                        index=[wafer_id_query, site_col, condition_col],
                        columns=parameter_col,
                        values=value_col,
                    ).reset_index()
                else:
                    # 如果找不到Site ID列，创建一个虚拟的
                    merged_data['Site_ID'] = merged_data.groupby([wafer_id_query, parameter_col]).cumcount() + 1
                    site_col = 'Site_ID'
                    
                    pivot_data = merged_data.pivot_table(
                        index=[wafer_id_query, site_col, condition_col],
                        columns=parameter_col,
                        values=value_col,
                        aggfunc='first'
                    ).reset_index()
                
                print(f"数据透视表形状: {pivot_data.shape}")
                
                return pivot_data, condition_types, measure_parameters, wafer_id_query, condition_col, site_col
                
            except Exception as e:
                print(f"创建数据透视表时出错: {e}")
                
                # 备用方法 - 不使用透视表，直接重塑数据
                transformed_data = merged_data[[wafer_id_query, condition_col]].drop_duplicates()
                
                if site_col:
                    site_data = merged_data[[wafer_id_query, site_col]].drop_duplicates()
                    transformed_data = pd.merge(transformed_data, site_data, on=wafer_id_query, how='left')
                else:
                    # 创建虚拟Site ID
                    merged_data['Site_ID'] = merged_data.groupby(wafer_id_query).cumcount() + 1
                    site_col = 'Site_ID'
                    site_data = merged_data[[wafer_id_query, site_col]].drop_duplicates()
                    transformed_data = pd.merge(transformed_data, site_data, on=wafer_id_query, how='left')
                
                # 为每个参数创建列
                for param in measure_parameters:
                    param_data = merged_data[merged_data[parameter_col] == param]
                    param_data = param_data[[wafer_id_query, site_col, value_col]].rename(columns={value_col: param})
                    transformed_data = pd.merge(transformed_data, param_data, on=[wafer_id_query, site_col], how='left')
                
                print(f"备用转换数据形状: {transformed_data.shape}")
                
                return transformed_data, condition_types, measure_parameters, wafer_id_query, condition_col, site_col
        
        except Exception as e:
            print(f"转换数据时出错: {e}")
            return None, None, None, None, None, None

    def create_sample_data(self):
        """创建模拟数据集，包含Site ID信息"""
        n_wafers = 30
        
        # 创建wafer IDs
        wafer_ids = [f'Wafer_{i:03d}' for i in range(1, n_wafers+1)]
        
        # 条件类型
        condition_types = ['Baseline', '2nd tool']
        
        # 创建condition_list数据
        condition_data = pd.DataFrame({
            'WaferID': wafer_ids,
            'Condition': np.random.choice(condition_types, size=n_wafers)
        })
        
        # 创建量测数据
        param_names = ['Con_M3LA', 'Con_M3LB', 'Rc_V2v', 'LK_M3LA', 'LK_M3LB']
        
        rows = []
        for wafer_id in wafer_ids:
            for param in param_names:
                # 为每个wafer和每个参数创建多个site测量
                n_sites = np.random.randint(1, 5)
                for site in range(1, n_sites+1):
                    # 随机生成0-9之间的值，添加少量异常值
                    value = np.random.uniform(0, 9)
                    
                    # 5%的概率生成异常值
                    if np.random.random() < 0.05:
                        value = value * (3 + np.random.random() * 2)  # 3-5倍的异常值
                    
                    rows.append({
                        'Wafer ID': wafer_id,
                        'Parameter Name': param,
                        'Site': f'Site_{site}',
                        'Site Value': value
                    })
        
        query_data = pd.DataFrame(rows)
        
        self.query_data = query_data
        self.condition_data = condition_data
        
        QMessageBox.information(self, "提示", "已创建模拟数据")

    def update_parameter_combo(self):
        if not self.available_parameters:
            return
        
        # 清除当前选项
        self.param_combo.clear()
        
        # 添加参数选项
        for param in self.available_parameters:
            self.param_combo.addItem(param)
        
        # 默认选择第一个参数
        if self.param_combo.count() > 0:
            self.current_parameter = self.available_parameters[0]
            self.update_plot()
            self.update_stats_view()  # 更新统计信息表

    def update_table_view(self):
        """更新数据表格视图"""
        if self.transformed_data is not None:
            self.table_model.setData(self.transformed_data)
            
            # 自动调整列宽
            header = self.table_view.horizontalHeader()
            for i in range(self.table_model.columnCount()):
                header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)

    def calculate_statistics(self, parameter, group_col, group_values, excluded_points=None):
        """计算统计信息：Mean, Std Dev, K-shift，直接使用所有site的数据"""
        stats_dict = {}
        
        for group in group_values:
            # 获取该组的所有数据(所有site，不做wafer平均)
            mask = self.transformed_data[group_col] == group
            group_data = self.transformed_data.loc[mask, parameter].dropna()
            
            # 排除被标记的点
            if excluded_points and parameter in excluded_points:
                exclude_points = excluded_points[parameter]
                for ex_group, ex_wafer_id, ex_site_id in exclude_points:
                    if ex_group == group:
                        # 排除特定wafer和site的点
                        wafer_mask = self.transformed_data[self.wafer_id_col] == ex_wafer_id
                        site_mask = self.transformed_data[self.site_col] == ex_site_id
                        exclude_mask = wafer_mask & site_mask & mask
                        group_data = group_data[~exclude_mask.reindex(group_data.index, fill_value=False)]
            
            if len(group_data) > 0:
                # 计算均值
                mean_value = np.mean(group_data)
                # 计算标准差
                std_dev = np.std(group_data, ddof=1)
                
                stats_dict[group] = {
                    'Mean': mean_value,
                    'Std Dev': std_dev,
                    'Count': len(group_data)
                }
            else:
                stats_dict[group] = {
                    'Mean': np.nan,
                    'Std Dev': np.nan,
                    'Count': 0
                }
        
        # 计算K-shift (如果有两个或更多组)
        if len(group_values) >= 2:
            for group in group_values:
                if 'base' in group.lower():
                    baseline_group = group_values[0]  
                else:
                    second_tool_group = group_values[1] 
            
            if (baseline_group in stats_dict and second_tool_group in stats_dict and
                not np.isnan(stats_dict[baseline_group]['Std Dev']) and
                stats_dict[baseline_group]['Std Dev'] != 0):
                
                stats_dict[second_tool_group]['K-shift'] = (
                    stats_dict[second_tool_group]['Mean'] - stats_dict[baseline_group]['Mean']
                ) / stats_dict[baseline_group]['Std Dev']
            else:
                if second_tool_group in stats_dict:
                    stats_dict[second_tool_group]['K-shift'] = np.nan
        
        return stats_dict

    def update_stats_view(self):
        """更新统计信息表格"""
        if self.transformed_data is None or self.current_parameter is None:
            return
            
        # 计算统计信息
        stats_dict = self.calculate_statistics(
            self.current_parameter,
            self.condition_col,
            self.condition_types,
            self.excluded_points
        )
        
        # 创建统计信息DataFrame
        stats_rows = []
        for group, stats in stats_dict.items():
            row = {'Condition': group}
            row.update(stats)
            stats_rows.append(row)
        
        stats_df = pd.DataFrame(stats_rows)
        
        # 如果存在，添加K-shift列
        if len(stats_rows) > 1 and 'K-shift' in stats_rows[1]:
            # 确保K-shift列在最后
            cols = [col for col in stats_df.columns if col != 'K-shift']
            if 'K-shift' in stats_df.columns:
                cols.append('K-shift')
            stats_df = stats_df[cols]
        
        # 更新统计表模型
        self.stats_model.setData(stats_df)
        
        # 自动调整列宽
        header = self.stats_view.horizontalHeader()
        for i in range(self.stats_model.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)

    def on_parameter_changed(self, index):
        """当参数选择改变时调用"""
        if index >= 0 and index < len(self.available_parameters):
            self.current_parameter = self.available_parameters[index]
            # 清除临时选择的点
            self.temp_selected_points = {}
            self.confirm_select_btn.setEnabled(False)
            self.update_plot()
            self.update_stats_view()  # 更新统计视图

    def update_plot(self, mark_only=False):
        """更新图表"""
        if self.transformed_data is None or self.current_parameter is None:
            return
            
        # 如果是首次加载或切换参数且不是仅标记模式，创建显示数据副本
        if (self.display_data is None or self.current_parameter not in self.excluded_points) and not mark_only:
            self.display_data = self.transformed_data.copy()
        
        # 更新箱形图
        self.update_box_plot(mark_only)
        
        # 更新QQ图
        self.update_qq_plot(mark_only)

    def update_box_plot(self, mark_only=False):
        """更新箱形图"""
        # 清除当前图表
        self.box_fig.clear()
        ax = self.box_fig.add_subplot(111)
        
        # 使用所有site数据，不做wafer平均
        plot_data = self.display_data.copy()
        
        # 确保Baseline总是第一个，2nd tool总是第二个
        ordered_groups = []
        for expected_group in ["Baseline", "2nd tool"]:
            if expected_group in self.condition_types:
                ordered_groups.append(expected_group)
        
        # 如果有其他不在预期内的组，也添加进来
        for group in self.condition_types:
            if group not in ordered_groups:
                ordered_groups.append(group)
        
        # 准备数据
        box_data = []
        labels = []
        
        for group in ordered_groups:
            # 获取当前组的所有site数据
            mask = plot_data[self.condition_col] == group
            group_data = plot_data.loc[mask, self.current_parameter].dropna()
            
            if len(group_data) > 0:
                box_data.append(group_data)
                labels.append(group)
        
        if not box_data:
            ax.text(0.5, 0.5, f"无数据可用于 {self.current_parameter}", 
                ha='center', va='center', transform=ax.transAxes)
            self.box_canvas.draw()
            return
        
        # 创建箱线图
        colors = []
        for label in labels:
            if label == "Baseline":
                colors.append('lightblue')
            elif label == "2nd tool":
                colors.append('lightgreen')
            else:
                colors.append('lightgray')
        
        # 绘制箱线图
        boxplot = ax.boxplot(box_data, patch_artist=True, labels=labels)
        
        # 设置颜色
        for i, patch in enumerate(boxplot['boxes']):
            if i < len(colors):
                patch.set_facecolor(colors[i])
        
        # 添加标题和标签
        ax.set_title(f'Box Plot - {self.current_parameter}')
        ax.set_ylabel(self.current_parameter)
        
        # 标记临时选择的点（用红色X）- 仅在标记模式下
        if mark_only and self.current_parameter in self.temp_selected_points and self.temp_selected_points[self.current_parameter]:
            excluded_data = []
            
            # 对每个组单独标记
            for group_idx, group in enumerate(labels):
                # 获取临时选择的点
                temp_selected = [
                    (wafer_id, site_id) for cond, wafer_id, site_id in self.temp_selected_points[self.current_parameter]
                    if cond == group
                ]
                
                if temp_selected:
                    original_data = self.transformed_data.copy()
                    for wafer_id, site_id in temp_selected:
                        wafer_mask = original_data[self.wafer_id_col] == wafer_id
                        site_mask = original_data[self.site_col] == site_id
                        group_mask = original_data[self.condition_col] == group
                        # 获取这个点的值
                        points = original_data[wafer_mask & site_mask & group_mask][self.current_parameter].dropna()
                        
                        if len(points) > 0:
                            # 添加到排除数据列表
                            for val in points:
                                excluded_data.append((group_idx + 1, val))
            
            # 在箱线图上标记这些点
            if excluded_data:
                x_positions, y_values = zip(*excluded_data)
                ax.scatter(x_positions, y_values, color='red', marker='x', s=100, alpha=0.7)
        
        # 刷新画布
        self.box_canvas.draw()

    def update_qq_plot(self, mark_only=False):
        """更新QQ图"""
        # 清除当前图表
        self.qq_fig.clear()
        ax = self.qq_fig.add_subplot(111)
        
        # 使用所有site数据，不做wafer平均
        plot_data = self.display_data.copy()
        
        # 确保Baseline和2nd tool始终是固定颜色
        color_map = {
            "Baseline": 'blue',
            "2nd tool": 'green'
        }
        marker_map = {
            "Baseline": 'o',
            "2nd tool": 's'
        }
        
        # 绘制的顺序 - 确保图例显示顺序一致
        ordered_groups = []
        for expected_group in ["Baseline", "2nd tool"]:
            if expected_group in self.condition_types:
                ordered_groups.append(expected_group)
        
        # 如果有其他不在预期内的组，也添加进来
        for group in self.condition_types:
            if group not in ordered_groups:
                ordered_groups.append(group)
        
        # 保存每个组的点数据，用于后续标记
        group_points = {}
        
        for group in ordered_groups:
            # 获取当前组的数据
            mask = plot_data[self.condition_col] == group
            group_data = plot_data.loc[mask, self.current_parameter].dropna()
            
            if len(group_data) == 0:
                continue
            
            # 保存原始数据点
            group_points[group] = {
                'wafer_ids': plot_data.loc[mask, self.wafer_id_col].values,
                'site_ids': plot_data.loc[mask, self.site_col].values,
                'values': group_data.values
            }
            
            # 排序数据
            sorted_data = np.sort(group_data)
            n = len(sorted_data)
            
            # JMP概率计算公式: (i-0.375)/(n+0.25)
            probabilities = np.array([(i + 1 - 0.375) / (n + 0.25) for i in range(n)])
            
            # 转换为正态分布的分位数
            norm_quantiles = stats.norm.ppf(probabilities)
            
            # 绘制 - 使用对应颜色和标记
            color = color_map.get(group, 'gray')  # 如果不是预期组，使用灰色
            marker = marker_map.get(group, '^')
            
            ax.plot(sorted_data, norm_quantiles, color=color, marker=marker,
                   linestyle='-', label=group, markersize=6)
        
        # 标记临时选择的点（红色X）- 仅在标记模式下
        if mark_only and self.current_parameter in self.temp_selected_points and self.temp_selected_points[self.current_parameter]:
            for group in ordered_groups:
                # 获取临时选择的点
                temp_selected = [
                    (wafer_id, site_id) for cond, wafer_id, site_id in self.temp_selected_points[self.current_parameter]
                    if cond == group
                ]
                
                if temp_selected and group in group_points:
                    # 获取原始数据中这些点的值和对应的分位数
                    original_data = self.transformed_data.copy()
                    
                    for wafer_id, site_id in temp_selected:
                        wafer_mask = original_data[self.wafer_id_col] == wafer_id
                        site_mask = original_data[self.site_col] == site_id
                        group_mask = original_data[self.condition_col] == group
                        # 获取这个点的值
                        points = original_data[wafer_mask & site_mask & group_mask][self.current_parameter].dropna()
                        
                        if len(points) > 0:
                            # 对每个点计算其对应的正态分位数
                            for value in points:
                                # 在对应组的数据中找到这个值应该在的位置
                                group_values = np.sort(group_points[group]['values'])
                                n = len(group_values)
                                
                                if n > 0:
                                    try:
                                        # 找到最接近的值的索引
                                        idx = min(range(len(group_values)), key=lambda i: abs(group_values[i] - value))
                                        # 计算对应的概率
                                        prob = (idx + 1 - 0.375) / (n + 0.25)
                                        # 计算正态分位数
                                        quantile = stats.norm.ppf(prob)
                                        
                                        # 在图上标记
                                        ax.scatter(value, quantile, color='red', marker='x', s=100, alpha=0.7)
                                    except Exception as e:
                                        print(f"标记QQ图点时出错: {e}")
    
        
        # 添加标题和标签
        ax.set_title(f'Normal Quantile Plot - {self.current_parameter}')
        ax.set_xlabel(self.current_parameter)
        ax.set_ylabel('Normal Quantile')
        
        # Y轴使用概率刻度
        prob_ticks = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99]
        quantile_ticks = stats.norm.ppf(prob_ticks)
        ax.set_yticks(quantile_ticks)
        ax.set_yticklabels([f'{p:.2f}' for p in prob_ticks])
        
        # 添加参考线
        ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
        
        # 添加图例
        ax.legend(loc='best')
        
        # 添加网格
        ax.grid(True, alpha=0.3)
        
        # 刷新画布
        self.qq_canvas.draw()

    def enable_selection_mode(self, mode):
        """启用选择模式"""
        # 禁用其他按钮，避免同时激活多个选择模式
        self.rect_select_btn.setEnabled(False)
        self.lasso_select_btn.setEnabled(False)
        
        # 清除临时选择的点
        self.temp_selected_points = {}
        
        # 在当前活跃的选项卡上启用选择
        current_tab_index = self.findChild(QTabWidget).currentIndex()
        
        if current_tab_index == 0:  # Box Plot
            self.box_canvas.enable_selection(mode, self.on_box_selection)
        else:  # QQ Plot
            self.qq_canvas.enable_selection(mode, self.on_qq_selection)

    def confirm_selection(self):
        """确认删除当前选择的点"""
        if not self.temp_selected_points or self.current_parameter not in self.temp_selected_points:
            return
        
        # 保存操作前的状态，用于上一步功能
        if self.current_parameter in self.excluded_points:
            prev_excluded = self.excluded_points[self.current_parameter].copy()
        else:
            prev_excluded = []
        prev_display_data = self.display_data.copy()
        self.operation_history.append((self.current_parameter, prev_excluded, prev_display_data))
        self.undo_select_btn.setEnabled(True)
        
        # 更新排除点列表
        if self.current_parameter not in self.excluded_points:
            self.excluded_points[self.current_parameter] = []
        
        # 添加临时选择的点
        for point in self.temp_selected_points[self.current_parameter]:
            if point not in self.excluded_points[self.current_parameter]:
                self.excluded_points[self.current_parameter].append(point)
        
        # 更新显示数据 - 从display_data中移除这些点
        for condition, wafer_id, site_id in self.temp_selected_points[self.current_parameter]:
            wafer_mask = self.display_data[self.wafer_id_col] == wafer_id
            site_mask = self.display_data[self.site_col] == site_id
            condition_mask = self.display_data[self.condition_col] == condition
            self.display_data = self.display_data[~(wafer_mask & site_mask & condition_mask)]
        
        # 清除临时选择
        self.temp_selected_points = {}
        
        # 更新图表和统计
        self.update_plot()
        self.update_stats_view()
        
        # 启用选择按钮
        self.rect_select_btn.setEnabled(True)
        self.lasso_select_btn.setEnabled(True)
        
        # 禁用确认按钮
        self.confirm_select_btn.setEnabled(False)    

    def on_box_selection(self, indices, line):
        """箱形图选择回调"""
        if not indices.size:
            return
            
        try:
            # 启用确认按钮
            self.confirm_select_btn.setEnabled(True)
            
            # 获取当前活跃的选项卡
            tab_widget = self.findChild(QTabWidget)
            
            # 确保Baseline总是第一个，2nd tool总是第二个
            ordered_groups = []
            for expected_group in ["Baseline", "2nd tool"]:
                if expected_group in self.condition_types:
                    ordered_groups.append(expected_group)
            
            # 如果有其他不在预期内的组，也添加进来
            for group in self.condition_types:
                if group not in ordered_groups:
                    ordered_groups.append(group)
            
            # 获取箱线图标签
            tick_labels = self.box_fig.axes[0].get_xticklabels()
            box_lines = self.box_fig.axes[0].lines
            
            # 找出所有箱线图中的线条和点
            line_index = -1
            for i, l in enumerate(box_lines):
                if l == line:
                    line_index = i
                    break
            
            # 如果找不到对应的线，可能是点击了散点图的点
            if line_index < 0:
                for i, art in enumerate(self.box_fig.axes[0].collections):
                    if line == art:
                        line_index = i
                        break
            
            # 还是找不到，尝试更广泛的查找
            if line_index < 0:
                # 检查位置来确定是哪个箱体
                x_pos = np.mean(line.get_xdata())
                line_index = int(x_pos) - 1
                
                if line_index < 0 or line_index >= len(ordered_groups):
                    QMessageBox.warning(self, "警告", "无法确定选择的组")
                    return
            
            # 确保索引在范围内
            if len(tick_labels) > 0 and line_index < len(tick_labels):
                group = tick_labels[line_index].get_text()
            else:
                group = ordered_groups[min(line_index, len(ordered_groups)-1)]
            
            # 获取所选组在当前显示数据中的所有点
            mask = self.display_data[self.condition_col] == group
            # 获取y坐标的所有点
            y_vals = line.get_ydata()[indices]
            
            # 找出与这些坐标接近的点
            selected_points = []  # 存储格式为 (group, wafer_id, site_id)
            for y_val in y_vals:
                # 找出接近这个y值的点
                group_data = self.display_data.loc[mask]
                # 计算与y值的距离
                distances = np.abs(group_data[self.current_parameter] - y_val)
                # 找出最接近的点
                if len(distances) > 0:
                    closest_idx = distances.nsmallest(1).index
                    if len(closest_idx) > 0:
                        # 获取对应的wafer ID和site ID
                        wafer_id = self.display_data.loc[closest_idx, self.wafer_id_col].values[0]
                        site_id = self.display_data.loc[closest_idx, self.site_col].values[0]
                        selected_points.append((group, wafer_id, site_id))
            
            if not selected_points:
                # 重新启用选择按钮
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                QMessageBox.warning(self, "警告", "未能找到匹配的数据点")
                return
            
            # 更新临时选择点列表
            if self.current_parameter not in self.temp_selected_points:
                self.temp_selected_points[self.current_parameter] = []
            
            # 添加新选择的点
            for point in selected_points:
                if point not in self.temp_selected_points[self.current_parameter]:
                    self.temp_selected_points[self.current_parameter].append(point)
            
            # 更新图表，仅标记选择的点
            self.update_plot(mark_only=True)
            
        except Exception as e:
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)
            QMessageBox.warning(self, "警告", f"处理选择时出错: {str(e)}")

    def on_qq_selection(self, indices, line):
        """QQ图选择回调"""
        if not indices.size:
            return
            
        try:
            # 启用确认按钮
            self.confirm_select_btn.setEnabled(True)
            
            # 确保有序的组
            ordered_groups = []
            for expected_group in ["Baseline", "2nd tool"]:
                if expected_group in self.condition_types:
                    ordered_groups.append(expected_group)
            
            for group in self.condition_types:
                if group not in ordered_groups:
                    ordered_groups.append(group)
            
            # 找出属于哪个组
            qq_lines = self.qq_fig.axes[0].get_lines()
            line_index = -1
            for i, l in enumerate(qq_lines):
                if l == line:
                    line_index = i
                    break
            
            # 如果找不到，尝试通过坐标判断是哪个组的线
            if line_index < 0:
                x_coords = line.get_xdata()[indices]
                y_coords = line.get_ydata()[indices]
                
                # 对于每个组，检查其线是否包含接近的点
                for i, l in enumerate(qq_lines):
                    l_xdata = l.get_xdata()
                    l_ydata = l.get_ydata()
                    
                    # 找出最接近的点
                    min_dist = float('inf')
                    for x, y in zip(x_coords, y_coords):
                        dists = np.sqrt((l_xdata - x)**2 + (l_ydata - y)**2)
                        nearest_dist = np.min(dists) if len(dists) > 0 else float('inf')
                        if nearest_dist < min_dist:
                            min_dist = nearest_dist
                            line_index = i
            
            # 找出对应的组
            if line_index < 0 or line_index >= len(ordered_groups):
                # 重新启用选择按钮
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                QMessageBox.warning(self, "警告", "无法确定选择的组")
                return
            
            group = ordered_groups[line_index]
            
            # 获取所选点的x值（实际测量值）
            x_vals = line.get_xdata()[indices]
            
            # 找出对应的晶圆
            selected_points = []  # 存储格式为 (group, wafer_id, site_id)
            mask = self.display_data[self.condition_col] == group
            group_data = self.display_data[mask]
            
            for x_val in x_vals:
                # 找出接近这个x值的点
                distances = np.abs(group_data[self.current_parameter] - x_val)
                if len(distances) > 0:
                    # 找出最接近的点
                    closest_idx = distances.nsmallest(1).index
                    if len(closest_idx) > 0:
                        # 获取对应的wafer ID和site ID
                        wafer_id = self.display_data.loc[closest_idx, self.wafer_id_col].values[0]
                        site_id = self.display_data.loc[closest_idx, self.site_col].values[0]
                        selected_points.append((group, wafer_id, site_id))
            
            if not selected_points:
                # 重新启用选择按钮
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                QMessageBox.warning(self, "警告", "未能找到匹配的数据点")
                return
            
            # 更新临时选择点列表
            if self.current_parameter not in self.temp_selected_points:
                self.temp_selected_points[self.current_parameter] = []
            
            # 添加新选择的点
            for point in selected_points:
                if point not in self.temp_selected_points[self.current_parameter]:
                    self.temp_selected_points[self.current_parameter].append(point)
            
            # 更新图表，仅标记选择的点
            self.update_plot(mark_only=True)
            
        except Exception as e:
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)
            QMessageBox.warning(self, "警告", f"处理选择时出错: {str(e)}")

    def clear_selection(self):
        """清除当前参数的选择"""
        if self.current_parameter in self.excluded_points:
            # 保存操作前的状态，用于上一步功能
            prev_excluded = self.excluded_points[self.current_parameter].copy()
            prev_display_data = self.display_data.copy()
            self.operation_history.append((self.current_parameter, prev_excluded, prev_display_data))
            self.undo_select_btn.setEnabled(True)
            
            # 删除当前参数的排除点
            del self.excluded_points[self.current_parameter]
            
            # 重置显示数据，使其与原始数据一致
            self.display_data = self.transformed_data.copy()
            
            # 清除临时选择
            if self.current_parameter in self.temp_selected_points:
                del self.temp_selected_points[self.current_parameter]
            self.confirm_select_btn.setEnabled(False)
            
            # 更新图表和统计
            self.update_plot()
            self.update_stats_view()
            
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)
        elif self.current_parameter in self.temp_selected_points:
            # 如果有临时选择但没有确认，清除临时选择
            del self.temp_selected_points[self.current_parameter]
            self.confirm_select_btn.setEnabled(False)
            
            # 更新图表，不显示临时标记
            self.update_plot()
            
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)  

    def clear_excluded_points(self):
        """清除所有排除点"""
        if self.excluded_points:
            # 保存操作前的状态
            self.operation_history = []  # 清空操作历史
            self.undo_select_btn.setEnabled(False)
            
            # 清空排除点和临时选择
            self.excluded_points = {}
            self.temp_selected_points = {}
            
            # 重置显示数据
            self.display_data = self.transformed_data.copy()
            
            # 更新图表和统计
            self.update_plot()
            self.update_stats_view()
            
            # 禁用确认按钮
            self.confirm_select_btn.setEnabled(False)
            
            # 启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)

    def undo_selection(self):
        """撤销上一次选择操作"""
        if not self.operation_history:
            return
        
        # 获取上一次操作前的状态
        last_operation = self.operation_history.pop()
        parameter, exclude_points, display_data_state = last_operation
        
        # 恢复排除点列表
        if exclude_points:
            self.excluded_points[parameter] = exclude_points
        else:
            # 如果之前没有排除点，删除该键
            if parameter in self.excluded_points:
                del self.excluded_points[parameter]
        
        # 恢复显示数据状态
        self.display_data = display_data_state.copy()
        
        # 清除临时选择
        self.temp_selected_points = {}
        self.confirm_select_btn.setEnabled(False)
        
        # 更新图表和统计视图
        self.update_plot()
        self.update_stats_view()
        
        # 如果没有历史操作了，禁用上一步按钮
        if not self.operation_history:
            self.undo_select_btn.setEnabled(False)
        
        # 启用选择按钮
        self.rect_select_btn.setEnabled(True)
        self.lasso_select_btn.setEnabled(True)   

    def export_excel(self):
        """导出Excel，保留原始数据"""
        if self.transformed_data is None:
            QMessageBox.warning(self, "警告", "没有可导出的数据")
            return
            
        file_name, _ = QFileDialog.getSaveFileName(
            self, "导出Excel", "Wafer_Measurement_Data.xlsx", "Excel Files (*.xlsx)"
        )
        
        if file_name:
            try:
                # 直接导出原始数据表格，简化处理
                self.transformed_data.to_excel(file_name, index=False)
                QMessageBox.information(self, "成功", f"原始数据已导出到: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"导出Excel时出错: {str(e)}")
    
    def create_ppt(self):
        """创建PPT报告，使用当前显示数据（已排除异常值）"""
        if self.transformed_data is None:
            QMessageBox.warning(self, "警告", "没有可导出的数据")
            return
            
        file_name, _ = QFileDialog.getSaveFileName(
            self, "创建PPT", "Wafer_Measurement_Analysis.pptx", "PowerPoint Files (*.pptx)"
        )
        
        if file_name:
            try:
                # 创建演示文稿
                prs = Presentation()
                
                # 设置幻灯片大小为标准尺寸(4:3)
                prs.slide_width = Inches(10)
                prs.slide_height = Inches(7.5)
                
                # 添加空白幻灯片
                blank_slide_layout = prs.slide_layouts[6]  # 空白布局
                slide = prs.slides.add_slide(blank_slide_layout)
                
                # 添加标题 - 位置调高
                title_shape = slide.shapes.add_textbox(Inches(0), Inches(0.1), Inches(10), Inches(0.5))
                title_frame = title_shape.text_frame
                title_para = title_frame.add_paragraph()
                title_para.text = "Wafer Measurement Analysis Report"
                title_para.alignment = PP_ALIGN.CENTER
                title_run = title_para.runs[0]
                title_run.font.size = Pt(20)
                title_run.font.bold = True
                
                # 左侧放置Box Plot
                left_panel_x = Inches(0.2)
                left_panel_y = Inches(0.7)  # 位置调高
                left_panel_width = Inches(3.5)
                left_panel_height = Inches(5.0)
                
                # 右侧放置Quantile Plot (2x3网格)
                right_panel_x = Inches(3.8)
                right_panel_y = Inches(0.7)  # 位置调高
                right_panel_width = Inches(6.0)
                right_panel_height = Inches(5.0)
                
                # 计算单个Box Plot的尺寸
                box_plot_height = left_panel_height / len(self.available_parameters)
                
                # 计算单个Quantile Plot的尺寸
                quantile_plot_width = right_panel_width / 2
                quantile_plot_height = right_panel_height / 3
                
                # 确保Baseline在前，2nd tool在后
                ordered_group_values = []
                for expected_group in ["Baseline", "2nd tool"]:
                    if expected_group in self.condition_types:
                        ordered_group_values.append(expected_group)
                
                # 添加其他可能的组
                for group in self.condition_types:
                    if group not in ordered_group_values:
                        ordered_group_values.append(group)
                
                # 获取正确的基线组和对照组
                baseline_group = ordered_group_values[0]  # 第一个组视为基线
                second_tool_group = ordered_group_values[1] if len(ordered_group_values) > 1 else None
                
                # 获取每个参数的统计数据，用于最后的表格
                all_stats = {}
                
                # 创建左侧Box Plot
                for i, parameter in enumerate(self.available_parameters):
                    # 计算Box Plot位置
                    y_pos = left_panel_y + i * box_plot_height
                    
                    # 创建Box Plot图像
                    fig = Figure(figsize=(4, 1.7), dpi=100)
                    ax = fig.add_subplot(111)
                    
                    # 准备数据
                    box_data = []
                    valid_labels = []
                    
                    for group in ordered_group_values:
                        # 使用当前的display_data（已排除异常值）
                        mask = self.display_data[self.condition_col] == group
                        group_data = self.display_data.loc[mask, parameter].dropna()
                        
                        if len(group_data) > 0:
                            box_data.append(group_data)
                            valid_labels.append(group)
                    
                    if not box_data:
                        ax.text(0.5, 0.5, f"无数据可用于 {parameter}", ha='center', va='center', transform=ax.transAxes)
                        continue
                    
                    # 创建箱线图
                    colors = []
                    for label in valid_labels:
                        if label == "Baseline":
                            colors.append('lightblue')
                        elif label == "2nd tool":
                            colors.append('lightgreen')
                        else:
                            colors.append('lightgray')  # 默认颜色
                    
                    boxplot = ax.boxplot(box_data, patch_artist=True, labels=valid_labels)
                    
                    for j, patch in enumerate(boxplot['boxes']):
                        if j < len(colors):
                            patch.set_facecolor(colors[j])
                    
                    # 添加标题
                    ax.set_title(f'Box Plot - {parameter}', fontsize=10)
                    ax.set_ylabel(parameter, fontsize=8)
                    ax.tick_params(axis='both', labelsize=7)
                    
                    fig.tight_layout()
                    
                    # 转换为字节流
                    buf = io.BytesIO()
                    fig.savefig(buf, format='png', bbox_inches='tight')
                    plt.close(fig)
                    buf.seek(0)
                    
                    # 添加到PPT
                    slide.shapes.add_picture(
                        buf, 
                        left_panel_x, 
                        y_pos, 
                        width=left_panel_width
                    )
                    
                    # 计算统计数据 - 使用当前参数的排除点
                    stats_dict = self.calculate_statistics(
                        parameter, 
                        self.condition_col, 
                        ordered_group_values,
                        self.excluded_points
                    )
                    all_stats[parameter] = stats_dict
                
                # 创建右侧Quantile Plot (2x3网格)
                grid_positions = [
                    # Col 1
                    (right_panel_x, right_panel_y),                              # Row 1, Col 1
                    (right_panel_x, right_panel_y + quantile_plot_height),       # Row 2, Col 1
                    (right_panel_x, right_panel_y + 2 * quantile_plot_height),   # Row 3, Col 1
                    # Col 2
                    (right_panel_x + quantile_plot_width, right_panel_y),                         # Row 1, Col 2
                    (right_panel_x + quantile_plot_width, right_panel_y + quantile_plot_height),  # Row 2, Col 2
                    (right_panel_x + quantile_plot_width, right_panel_y + 2 * quantile_plot_height) # Row 3, Col 2
                ]
                
                # 最多放置6个Quantile Plot
                for i, parameter in enumerate(self.available_parameters[:6]):
                    # 计算Quantile Plot位置
                    if i < len(grid_positions):
                        x_pos, y_pos = grid_positions[i]
                        
                        # 创建QQ Plot图像
                        fig = Figure(figsize=(2.9, 1.7), dpi=100)
                        ax = fig.add_subplot(111)
                        
                        # 确保Baseline和2nd tool始终是固定颜色
                        color_map = {
                            "Baseline": 'blue',
                            "2nd tool": 'green'
                        }
                        marker_map = {
                            "Baseline": 'o',
                            "2nd tool": 's'
                        }
                        
                        for group in ordered_group_values:
                            # 使用当前的display_data（已排除异常值）
                            mask = self.display_data[self.condition_col] == group
                            group_data = self.display_data.loc[mask, parameter].dropna()
                            
                            if len(group_data) == 0:
                                continue
                            
                            # 排序数据
                            sorted_data = np.sort(group_data)
                            n = len(sorted_data)
                            
                            # JMP概率计算公式: (i-0.375)/(n+0.25)
                            probabilities = np.array([(i + 1 - 0.375) / (n + 0.25) for i in range(n)])
                            
                            # 转换为正态分布的分位数
                            norm_quantiles = stats.norm.ppf(probabilities)
                            
                            # 绘制 - 使用对应颜色和标记
                            color = color_map.get(group, 'gray')  # 如果不是预期组，使用灰色
                            marker = marker_map.get(group, '^')
                            
                            ax.plot(sorted_data, norm_quantiles, color=color, marker=marker,
                                   linestyle='-', label=group, markersize=4)
                        
                        # 添加标题
                        ax.set_title(parameter, fontsize=10)
                        
                        # 添加轴标签
                        ax.set_xlabel(parameter, fontsize=8)
                        ax.set_ylabel('Normal Quantile', fontsize=8)
                        
                        # Y轴使用概率刻度
                        prob_ticks = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99]
                        quantile_ticks = stats.norm.ppf(prob_ticks)
                        ax.set_yticks(quantile_ticks)
                        ax.set_yticklabels([f'{p:.2f}' for p in prob_ticks], fontsize=7)
                        ax.tick_params(axis='x', labelsize=7)
                        
                        # 添加参考线
                        ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
                        
                        # 添加图例
                        ax.legend(loc='best', fontsize=7)
                        
                        # 添加网格
                        ax.grid(True, alpha=0.3)
                        
                        fig.tight_layout()
                        
                        # 转换为字节流
                        buf = io.BytesIO()
                        fig.savefig(buf, format='png', bbox_inches='tight')
                        plt.close(fig)
                        buf.seek(0)
                        
                        # 添加到PPT
                        slide.shapes.add_picture(
                            buf, 
                            x_pos, 
                            y_pos, 
                            width=quantile_plot_width
                        ) 
                # 创建底部的统计表格 - 调整位置和大小
                table_rows = len(self.available_parameters) + 2  # 参数数量 + 标题两行
                table_cols = 5  # Condition, BSL Mean, BSL Std Dev, 2nd Tool Mean, K-shift
                
                table = slide.shapes.add_table(
                    table_rows, 
                    table_cols,
                    Inches(0.5), 
                    Inches(5.7),  # 位置略向上调整，避免超出页面
                    Inches(9), 
                    Inches(1.6)
                ).table
                
                # 设置列宽
                table.columns[0].width = Inches(2.0)
                for i in range(1, 5):
                    table.columns[i].width = Inches(1.75)
                
                # 添加表头 - 完全符合JMP风格
                header_cells = [
                    "Condition", baseline_group, "", second_tool_group, ""
                ]
                for i, text in enumerate(header_cells):
                    cell = table.cell(0, i)
                    cell.text = text if text is not None else ""
                    # 安全地设置粗体和字体大小
                    para = cell.text_frame.paragraphs[0]
                    para.alignment = PP_ALIGN.CENTER
                    if not para.runs:
                        run = para.add_run()
                        run.text = text if text is not None else ""
                    else:
                        run = para.runs[0]
                    run.font.bold = True
                    run.font.size = Pt(11)
                
                # 第二行表头
                subheader_cells = [
                    "Statistics", "Mean", "Std Dev", "Mean", "K-shift"
                ]
                for i, text in enumerate(subheader_cells):
                    cell = table.cell(1, i)
                    cell.text = text
                    # 安全地设置粗体和字体大小
                    para = cell.text_frame.paragraphs[0]
                    para.alignment = PP_ALIGN.CENTER
                    if not para.runs:
                        run = para.add_run()
                        run.text = text
                    else:
                        run = para.runs[0]
                    run.font.bold = True
                    run.font.size = Pt(11)
                
                # 添加数据行
                for i, parameter in enumerate(self.available_parameters):
                    stats_dict = all_stats.get(parameter, {})
                    
                    if not stats_dict:
                        continue
                        
                    # 准备数据
                    baseline_stats = stats_dict.get(baseline_group, {})
                    second_tool_stats = stats_dict.get(second_tool_group, {}) if second_tool_group else {}
                    
                    # 为小值启用科学记号
                    def format_value(value, param_name):
                        if value is None or np.isnan(value):
                            return 'N/A'
                        
                        # 判断是否为非常小的值 (例如LK类似的量级)
                        if 'LK' in param_name and abs(value) < 0.001:
                            return f"{value:.4e}"  # 使用科学记号
                        elif abs(value) < 0.0001:  # 其他很小的值也使用科学记号
                            return f"{value:.4e}"
                        else:
                            return f"{value:.4f}"  # 常规数值使用固定小数点
                    
                    row_data = [
                        parameter,
                        format_value(baseline_stats.get('Mean', np.nan), parameter) if 'Mean' in baseline_stats else 'N/A',
                        format_value(baseline_stats.get('Std Dev', np.nan), parameter) if 'Std Dev' in baseline_stats else 'N/A',
                        format_value(second_tool_stats.get('Mean', np.nan), parameter) if 'Mean' in second_tool_stats else 'N/A',
                        format_value(second_tool_stats.get('K-shift', np.nan), parameter) if 'K-shift' in second_tool_stats else 'N/A'
                    ]
                    
                    # 填充表格
                    for j, text in enumerate(row_data):
                        if i + 2 < table_rows and j < table_cols:  # 防止索引越界
                            cell = table.cell(i + 2, j)
                            cell.text = text
                            para = cell.text_frame.paragraphs[0]
                            para.alignment = PP_ALIGN.CENTER
                            if not para.runs:
                                run = para.add_run()
                                run.text = text
                            else:
                                run = para.runs[0]
                            run.font.size = Pt(10)
                
                # 保存演示文稿
                prs.save(file_name)
                QMessageBox.information(self, "成功", f"已创建PPT文件: {file_name}")
                
            except Exception as e:
                QMessageBox.critical(self, "错误", f"创建PPT时出错: {str(e)}")

    def show_about(self):
        """显示关于对话框"""
        about_text = """
        <h3>晶圆测量分析工具</h3>
        <p>版本: 1.0</p>
        <p>这是一个用于分析晶圆测量数据的工具，支持：</p>
        <ul>
            <li>数据加载和处理</li>
            <li>交互式箱形图和QQ图</li>
            <li>异常值识别和标记</li>
            <li>统计分析</li>
            <li>导出Excel和PPT报告</li>
        </ul>
        <p>使用说明:</p>
        <ol>
            <li>加载查询数据和条件数据（或使用模拟数据）</li>
            <li>处理数据后，在下拉菜单选择要分析的参数</li>
            <li>在箱形图或QQ图上，使用矩形选择或套索选择工具标记异常值</li>
            <li>点击"确认删除"按钮应用更改，从图表中移除选中的点</li>
            <li>可以导出Excel（保留原始数据）或创建PPT报告（排除标记的点）</li>
            <li>使用"上一步"按钮可以撤销上一次操作</li>
        </ol>
        <p>&copy; 2023 晶圆测量分析工具</p>
        """
        QMessageBox.about(self, "关于", about_text)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WaferAnalysisApp()
    window.show()
    sys.exit(app.exec())

import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
import io
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qtagg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
from matplotlib.widgets import LassoSelector, RectangleSelector
from matplotlib.path import Path

from PyQt6.QtWidgets import (QApplication, QMainWindow, QPushButton, QVBoxLayout, QHBoxLayout,
                           QWidget, QTableView, QHeaderView, QLabel, QComboBox, QFileDialog,
                           QMessageBox, QSplitter, QTabWidget, QGroupBox)
from PyQt6.QtCore import Qt, QAbstractTableModel, QModelIndex
from PyQt6.QtGui import QAction

from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.enum.text import PP_ALIGN


# 用于在QTableView中显示pandas DataFrame的自定义模型
class PandasModel(QAbstractTableModel):
    def __init__(self, data=None):
        super().__init__()
        self._data = pd.DataFrame() if data is None else data

    def rowCount(self, parent=QModelIndex()):
        return self._data.shape[0]

    def columnCount(self, parent=QModelIndex()):
        return self._data.shape[1]

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None

        if role == Qt.ItemDataRole.DisplayRole:
            value = self._data.iloc[index.row(), index.column()]
            # 处理特殊值的显示
            if pd.isna(value):
                return ""
            elif isinstance(value, (float, np.float64)):
                if abs(value) < 0.0001:
                    return f"{value:.4e}"
                else:
                    return f"{value:.4f}"
            else:
                return str(value)

        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                return str(self._data.columns[section])
            else:
                return str(section + 1)
        return None

    def setData(self, data):
        self._data = data
        self.layoutChanged.emit()


# 自定义的Figure Canvas，支持交互式选择
class InteractiveFigureCanvas(FigureCanvas):
    def __init__(self, fig, parent=None):
        super().__init__(fig)
        self.setParent(parent)
        self.figure = fig
        self.selected_points = []
        self.wafer_ids = []
        self.selector = None
        self.callback = None

    def enable_selection(self, mode='rectangle', callback=None):
        """启用选择模式，可以是'rectangle'或'lasso'"""
        if self.figure.axes:
            ax = self.figure.axes[0]
            self.callback = callback

            if mode == 'rectangle':
                self.selector = RectangleSelector(
                    ax, self.on_select, useblit=True,
                    button=[1], minspanx=5, minspany=5,
                    spancoords='pixels', interactive=True
                )
            elif mode == 'lasso':
                self.selector = LassoSelector(
                    ax, self.on_select_lasso, useblit=True
                )

    def on_select(self, eclick, erelease):
        """矩形选择回调"""
        if not self.figure.axes:
            return

        ax = self.figure.axes[0]
        x1, y1 = eclick.xdata, eclick.ydata
        x2, y2 = erelease.xdata, erelease.ydata

        # 获取所有点的坐标
        for line in ax.get_lines():
            xdata = line.get_xdata()
            ydata = line.get_ydata()

            # 找出在选择区域内的点
            selected_indices = np.where(
                (xdata >= min(x1, x2)) & (xdata <= max(x1, x2)) &
                (ydata >= min(y1, y2)) & (ydata <= max(y1, y2))
            )[0]

            if len(selected_indices) > 0 and self.callback:
                self.callback(selected_indices, line)

    def on_select_lasso(self, verts):
        """套索选择回调"""
        if not self.figure.axes:
            return

        ax = self.figure.axes[0]
        path = Path(verts)

        # 获取所有点的坐标
        for line in ax.get_lines():
            xdata = line.get_xdata()
            ydata = line.get_ydata()
            coords = np.column_stack([xdata, ydata])

            # 找出在套索区域内的点
            selected_indices = np.where(path.contains_points(coords))[0]

            if len(selected_indices) > 0 and self.callback:
                self.callback(selected_indices, line)


class WaferAnalysisApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("晶圆测量分析工具")
        self.setGeometry(100, 100, 1280, 800)

        # 数据存储
        self.query_data = None
        self.condition_data = None
        self.transformed_data = None
        self.cleaned_data = None
        self.wafer_id_col = None
        self.condition_col = None
        self.available_parameters = []
        self.condition_types = []
        self.current_parameter = None
        self.excluded_points = {}  # 存储被排除的点 {parameter: [(condition, wafer_id), ...]}

        # 设置菜单栏
        self.create_menu_bar()

        # 设置UI
        self.setup_ui()

    def create_menu_bar(self):
        # 创建菜单栏
        menu_bar = self.menuBar()

        # 文件菜单
        file_menu = menu_bar.addMenu("文件")

        # 打开查询数据
        open_query_action = QAction("打开查询数据", self)
        open_query_action.triggered.connect(self.load_query_data)
        file_menu.addAction(open_query_action)

        # 打开条件数据
        open_cond_action = QAction("打开条件数据", self)
        open_cond_action.triggered.connect(self.load_condition_data)
        file_menu.addAction(open_cond_action)

        file_menu.addSeparator()

        # 导出Excel
        export_excel_action = QAction("导出Excel", self)
        export_excel_action.triggered.connect(self.export_excel)
        file_menu.addAction(export_excel_action)

        # 创建PPT
        create_ppt_action = QAction("创建PPT报告", self)
        create_ppt_action.triggered.connect(self.create_ppt)
        file_menu.addAction(create_ppt_action)

        file_menu.addSeparator()

        # 退出
        exit_action = QAction("退出", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # 数据菜单
        data_menu = menu_bar.addMenu("数据")

        # 处理数据
        process_action = QAction("处理数据", self)
        process_action.triggered.connect(self.process_data)
        data_menu.addAction(process_action)

        # 清除排除点
        clear_exclude_action = QAction("清除排除点", self)
        clear_exclude_action.triggered.connect(self.clear_excluded_points)
        data_menu.addAction(clear_exclude_action)

        # 帮助菜单
        help_menu = menu_bar.addMenu("帮助")

        # 关于
        about_action = QAction("关于", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

    def setup_ui(self):
        # 主布局
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # 顶部控制区域
        top_controls = QWidget()
        top_layout = QHBoxLayout(top_controls)

        # 文件上传区域
        file_group = QGroupBox("数据文件")
        file_layout = QHBoxLayout(file_group)

        self.query_btn = QPushButton("上传查询数据")
        self.condition_btn = QPushButton("上传条件数据")
        self.process_btn = QPushButton("处理数据")

        self.query_btn.clicked.connect(self.load_query_data)
        self.condition_btn.clicked.connect(self.load_condition_data)
        self.process_btn.clicked.connect(self.process_data)

        file_layout.addWidget(self.query_btn)
        file_layout.addWidget(self.condition_btn)
        file_layout.addWidget(self.process_btn)

        # 参数选择区域
        param_group = QGroupBox("参数选择")
        param_layout = QHBoxLayout(param_group)

        param_label = QLabel("选择参数:")
        self.param_combo = QComboBox()
        self.param_combo.currentIndexChanged.connect(self.on_parameter_changed)
        
        param_layout.addWidget(param_label)
        param_layout.addWidget(self.param_combo)

        # 导出区域
        export_group = QGroupBox("导出")
        export_layout = QHBoxLayout(export_group)

        self.export_excel_btn = QPushButton("导出Excel")
        self.export_ppt_btn = QPushButton("创建PPT")
        
        self.export_excel_btn.clicked.connect(self.export_excel)
        self.export_ppt_btn.clicked.connect(self.create_ppt)
        
        export_layout.addWidget(self.export_excel_btn)
        export_layout.addWidget(self.export_ppt_btn)

        # 添加到顶部布局
        top_layout.addWidget(file_group)
        top_layout.addWidget(param_group)
        top_layout.addWidget(export_group)

        # 主分割窗口
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # 左侧数据表格
        table_widget = QWidget()
        table_layout = QVBoxLayout(table_widget)
        table_label = QLabel("数据表格")
        self.table_view = QTableView()
        self.table_model = PandasModel()
        self.table_view.setModel(self.table_model)
        
        table_layout.addWidget(table_label)
        table_layout.addWidget(self.table_view)
        
        # 右侧图表区域
        plot_widget = QWidget()
        plot_layout = QVBoxLayout(plot_widget)
        
        # 创建选项卡窗口用于Box Plot和QQ Plot
        tab_widget = QTabWidget()
        
        # Box Plot 选项卡
        self.box_tab = QWidget()
        box_layout = QVBoxLayout(self.box_tab)
        
        self.box_fig = Figure(figsize=(5, 4), dpi=100)
        self.box_canvas = InteractiveFigureCanvas(self.box_fig)
        self.box_toolbar = NavigationToolbar(self.box_canvas, self.box_tab)
        
        box_layout.addWidget(self.box_toolbar)
        box_layout.addWidget(self.box_canvas)
        
        # QQ Plot 选项卡
        self.qq_tab = QWidget()
        qq_layout = QVBoxLayout(self.qq_tab)
        
        self.qq_fig = Figure(figsize=(5, 4), dpi=100)
        self.qq_canvas = InteractiveFigureCanvas(self.qq_fig)
        self.qq_toolbar = NavigationToolbar(self.qq_canvas, self.qq_tab)
        
        qq_layout.addWidget(self.qq_toolbar)
        qq_layout.addWidget(self.qq_canvas)
        
        # 添加选项卡
        tab_widget.addTab(self.box_tab, "箱形图")
        tab_widget.addTab(self.qq_tab, "Q-Q图")
        
        plot_layout.addWidget(tab_widget)
        
        # 右下方控制区域
        plot_controls = QWidget()
        plot_controls_layout = QHBoxLayout(plot_controls)
        
        self.rect_select_btn = QPushButton("矩形选择")
        self.lasso_select_btn = QPushButton("套索选择")
        self.clear_select_btn = QPushButton("清除选择")
        
        self.rect_select_btn.clicked.connect(lambda: self.enable_selection_mode('rectangle'))
        self.lasso_select_btn.clicked.connect(lambda: self.enable_selection_mode('lasso'))
        self.clear_select_btn.clicked.connect(self.clear_selection)
        
        plot_controls_layout.addWidget(self.rect_select_btn)
        plot_controls_layout.addWidget(self.lasso_select_btn)
        plot_controls_layout.addWidget(self.clear_select_btn)
        
        plot_layout.addWidget(plot_controls)
        
        # 添加到分割窗口
        splitter.addWidget(table_widget)
        splitter.addWidget(plot_widget)
        splitter.setSizes([400, 800])  # 设置初始大小比例
        
        # 添加到主布局
        main_layout.addWidget(top_controls)
        main_layout.addWidget(splitter, 1)  # 1表示拉伸因子

        # 初始状态设置
        self.export_excel_btn.setEnabled(False)
        self.export_ppt_btn.setEnabled(False)
        self.param_combo.setEnabled(False)
        self.rect_select_btn.setEnabled(False)
        self.lasso_select_btn.setEnabled(False)
        self.clear_select_btn.setEnabled(False)

    def load_query_data(self):
        """加载查询数据文件"""
        file_name, _ = QFileDialog.getOpenFileName(
            self, "选择查询数据文件", "", "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        
        if file_name:
            try:
                if file_name.endswith('.csv'):
                    self.query_data = pd.read_csv(file_name)
                else:
                    self.query_data = pd.read_excel(file_name)
                
                QMessageBox.information(self, "成功", f"已加载查询数据: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"加载数据时出错: {str(e)}")

    def load_condition_data(self):
        """加载条件数据文件"""
        file_name, _ = QFileDialog.getOpenFileName(
            self, "选择条件数据文件", "", "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        
        if file_name:
            try:
                if file_name.endswith('.csv'):
                    self.condition_data = pd.read_csv(file_name)
                else:
                    self.condition_data = pd.read_excel(file_name)
                
                QMessageBox.information(self, "成功", f"已加载条件数据: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"加载数据时出错: {str(e)}")

    def process_data(self):
        """处理数据"""
        if self.query_data is None or self.condition_data is None:
            if self.query_data is None and self.condition_data is None:
                # 如果两个数据都未加载，创建模拟数据
                self.create_sample_data()
            else:
                QMessageBox.warning(self, "警告", "请先加载查询数据和条件数据")
                return
        
        try:
            # 处理数据
            transformed_data, condition_types, measure_parameters, wafer_id_col, condition_col = self.transform_data()
            
            if transformed_data is not None:
                self.transformed_data = transformed_data
                self.condition_types = condition_types
                self.wafer_id_col = wafer_id_col
                self.condition_col = condition_col
                
                # 清除排除点
                self.excluded_points = {}
                
                # 保存原始转换数据
                self.cleaned_data = self.transformed_data.copy()
                
                # 更新可用参数
                self.available_parameters = []
                for param in measure_parameters:
                    if param in transformed_data.columns:
                        self.available_parameters.append(param)
                
                if len(self.available_parameters) == 0:
                    # 如果没有找到可用参数，尝试使用非ID和非条件列
                    for col in transformed_data.columns:
                        if "wafer" not in col.lower() and col != condition_col:
                            self.available_parameters.append(col)
                
                # 更新UI
                self.update_parameter_combo()
                self.update_table_view()
                
                # 启用功能按钮
                self.export_excel_btn.setEnabled(True)
                self.export_ppt_btn.setEnabled(True)
                self.param_combo.setEnabled(True)
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                self.clear_select_btn.setEnabled(True)
                
                QMessageBox.information(self, "成功", "数据处理完成")
            else:
                QMessageBox.warning(self, "警告", "数据处理失败")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"处理数据时出错: {str(e)}")

    def transform_data(self):
        """转换数据，合并查询数据和条件数据"""
        try:
            # 查找查询数据中的Wafer ID列
            wafer_id_query = "Wafer ID" if "Wafer ID" in self.query_data.columns else "WaferID"
            if wafer_id_query not in self.query_data.columns:
                # 寻找可能包含wafer id的列
                for col in self.query_data.columns:
                    if "wafer" in col.lower():
                        wafer_id_query = col
                        break
            
            # 查找条件数据中的WaferID列
            wafer_id_condition = "WaferID" if "WaferID" in self.condition_data.columns else "Wafer ID"
            if wafer_id_condition not in self.condition_data.columns:
                # 寻找可能包含wafer id的列
                for col in self.condition_data.columns:
                    if "wafer" in col.lower():
                        wafer_id_condition = col
                        break
            
            # 查找参数名列和值列
            parameter_col = None
            value_col = None
            for col in self.query_data.columns:
                if "Parameter Name" in col or "name" in col.lower():
                    parameter_col = col
                elif "value" in col.lower() or "site value" in col.lower():
                    value_col = col
            
            # 查找条件列
            condition_col = None
            for col in self.condition_data.columns:
                if "condition" in col.lower():
                    condition_col = col
                    break
            
            # 获取条件类型（通常是Baseline和2nd tool）
            if condition_col and condition_col in self.condition_data.columns:
                condition_types = self.condition_data[condition_col].unique()
            else:
                condition_types = ["Baseline", "2nd tool"]
            
            # 获取参数列表
            if parameter_col and parameter_col in self.query_data.columns:
                measure_parameters = self.query_data[parameter_col].unique()
            else:
                measure_parameters = ["Con_M3LA", "Con_M3LB", "Rc_V2v", "LK_M3LA", "LK_M3LB"]
            
            # 合并数据
            merged_data = pd.merge(
                self.query_data,
                self.condition_data,
                left_on=wafer_id_query,
                right_on=wafer_id_condition,
                how='left'
            )
            
            # 创建数据透视表
            try:
                # 先按Wafer ID和Parameter Name取平均，再创建透视表
                grouped_data = merged_data.groupby([wafer_id_query, parameter_col, condition_col])[value_col].mean().reset_index()
                
                pivot_data = grouped_data.pivot_table(
                    index=[wafer_id_query, condition_col],
                    columns=parameter_col,
                    values=value_col
                ).reset_index()
                
                return pivot_data, condition_types, measure_parameters, wafer_id_query, condition_col
            
            except Exception as e:
                print(f"创建数据透视表时出错: {e}")
                
                # 备用方法
                # 获取唯一的参数
                unique_params = merged_data[parameter_col].unique()
                
                # 创建新的数据框
                transformed_data = merged_data[[wafer_id_query, condition_col]].drop_duplicates()
                
                # 为每个参数创建列
                for param in unique_params:
                    param_data = merged_data[merged_data[parameter_col] == param]
                    param_data_grouped = param_data.groupby(wafer_id_query)[value_col].mean().reset_index()
                    param_data_grouped = param_data_grouped.rename(columns={value_col: param})
                    
                    # 合并到转换后的数据
                    transformed_data = pd.merge(transformed_data, param_data_grouped, on=wafer_id_query, how='left')
                
                return transformed_data, condition_types, measure_parameters, wafer_id_query, condition_col
        
        except Exception as e:
            print(f"转换数据时出错: {e}")
            return None, None, None, None, None

    def create_sample_data(self):
        """创建模拟数据集"""
        n_wafers = 30
        
        # 创建wafer IDs
        wafer_ids = [f'Wafer_{i:03d}' for i in range(1, n_wafers+1)]
        
        # 条件类型
        condition_types = ['Baseline', '2nd tool']
        
        # 创建condition_list数据
        condition_data = pd.DataFrame({
            'WaferID': wafer_ids,
            'Condition': np.random.choice(condition_types, size=n_wafers)
        })
        
        # 创建量测数据
        param_names = ['Con_M3LA', 'Con_M3LB', 'Rc_V2v', 'LK_M3LA', 'LK_M3LB']
        
        rows = []
        for wafer_id in wafer_ids:
            for param in param_names:
                # 为每个wafer和每个参数创建多个site测量
                n_sites = np.random.randint(1, 5)
                for site in range(1, n_sites+1):
                    # 随机生成0-9之间的值，添加少量异常值
                    value = np.random.uniform(0, 9)
                    
                    # 5%的概率生成异常值
                    if np.random.random() < 0.05:
                        value = value * (3 + np.random.random() * 2)  # 3-5倍的异常值
                    
                    rows.append({
                        'Wafer ID': wafer_id,
                        'Parameter Name': param,
                        'Site': f'Site_{site}',
                        'Site Value': value
                    })
        
        query_data = pd.DataFrame(rows)
        
        self.query_data = query_data
        self.condition_data = condition_data
        
        QMessageBox.information(self, "提示", "已创建模拟数据")

    def update_parameter_combo(self):
        """更新参数下拉选择框"""
        if not self.available_parameters:
            return
        
        # 清除当前选项
        self.param_combo.clear()
        
        # 添加参数选项
        for param in self.available_parameters:
            self.param_combo.addItem(param)
        
        # 默认选择第一个参数
        if self.param_combo.count() > 0:
            self.current_parameter = self.available_parameters[0]
            self.update_plot()

    def update_table_view(self):
        """更新数据表格视图"""
        if self.transformed_data is not None:
            self.table_model.setData(self.transformed_data)
            
            # 自动调整列宽
            header = self.table_view.horizontalHeader()
            for i in range(self.table_model.columnCount()):
                header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)

    def on_parameter_changed(self, index):
        """当参数选择改变时调用"""
        if index >= 0 and index < len(self.available_parameters):
            self.current_parameter = self.available_parameters[index]
            self.update_plot()

    def update_plot(self):
        """更新图表"""
        if self.transformed_data is None or self.current_parameter is None:
            return
        
        # 更新箱形图
        self.update_box_plot()
        
        # 更新QQ图
        self.update_qq_plot()

    def update_box_plot(self):
        """更新箱形图"""
        # 清除当前图表
        self.box_fig.clear()
        ax = self.box_fig.add_subplot(111)
        
        # 确保Baseline总是第一个，2nd tool总是第二个
        ordered_groups = []
        for expected_group in ["Baseline", "2nd tool"]:
            if expected_group in self.condition_types:
                ordered_groups.append(expected_group)
        
        # 如果有其他不在预期内的组，也添加进来
        for group in self.condition_types:
            if group not in ordered_groups:
                ordered_groups.append(group)
        
        # 准备数据
        box_data = []
        labels = []
        
        for group in ordered_groups:
            # 获取当前组和参数的数据
            mask = self.transformed_data[self.condition_col] == group
            group_data = self.transformed_data.loc[mask, self.current_parameter].dropna()
            
            # 排除被标记的点
            if self.current_parameter in self.excluded_points:
                excluded_wafers = [wafer_id for condition, wafer_id in self.excluded_points[self.current_parameter] 
                                  if condition == group]
                if excluded_wafers:
                    # 排除这些wafer的数据
                    exclude_mask = self.transformed_data[self.wafer_id_col].isin(excluded_wafers)
                    group_data = group_data[~exclude_mask[mask]]
            
            if len(group_data) > 0:
                box_data.append(group_data)
                labels.append(group)
        
        if not box_data:
            ax.text(0.5, 0.5, f"无数据可用于 {self.current_parameter}", 
                   ha='center', va='center', transform=ax.transAxes)
            self.box_canvas.draw()
            return
        
        # 创建箱线图
        colors = []
        for label in labels:
            if label == "Baseline":
                colors.append('lightblue')
            elif label == "2nd tool":
                colors.append('lightgreen')
            else:
                colors.append('lightgray')  # 默认颜色
        
        # 绘制箱线图
        boxplot = ax.boxplot(box_data, patch_artist=True, labels=labels)
        
        # 设置颜色
        for i, patch in enumerate(boxplot['boxes']):
            if i < len(colors):
                patch.set_facecolor(colors[i])
        
        # 添加标题和标签
        ax.set_title(f'Box Plot - {self.current_parameter}')
        ax.set_ylabel(self.current_parameter)
        
        # 刷新画布
        self.box_canvas.draw()

    def update_qq_plot(self):
        """更新QQ图"""
        # 清除当前图表
        self.qq_fig.clear()
        ax = self.qq_fig.add_subplot(111)
        
        # 确保Baseline和2nd tool始终是固定颜色
        color_map = {
            "Baseline": 'blue',
            "2nd tool": 'green'
        }
        marker_map = {
            "Baseline": 'o',
            "2nd tool": 's'
        }
        
        # 绘制的顺序 - 确保图例显示顺序一致
        ordered_groups = []
        for expected_group in ["Baseline", "2nd tool"]:
            if expected_group in self.condition_types:
                ordered_groups.append(expected_group)
        
        # 如果有其他不在预期内的组，也添加进来
        for group in self.condition_types:
            if group not in ordered_groups:
                ordered_groups.append(group)
        
        for group in ordered_groups:
            # 获取当前组的数据
            mask = self.transformed_data[self.condition_col] == group
            group_data = self.transformed_data.loc[mask, self.current_parameter].dropna()
            
            # 排除被标记的点
            if self.current_parameter in self.excluded_points:
                excluded_wafers = [wafer_id for condition, wafer_id in self.excluded_points[self.current_parameter] 
                                  if condition == group]
                if excluded_wafers:
                    # 排除这些wafer的数据
                    exclude_mask = self.transformed_data[self.wafer_id_col].isin(excluded_wafers)
                    group_data = group_data[~exclude_mask[mask]]
            
            if len(group_data) == 0:
                continue
            
            # 排序数据
            sorted_data = np.sort(group_data)
            n = len(sorted_data)
            
            # JMP概率计算公式: (i-0.375)/(n+0.25)
            probabilities = np.array([(i + 1 - 0.375) / (n + 0.25) for i in range(n)])
            
            # 转换为正态分布的分位数
            norm_quantiles = stats.norm.ppf(probabilities)
            
            # 绘制 - 使用对应颜色和标记
            color = color_map.get(group, 'gray')  # 如果不是预期组，使用灰色
            marker = marker_map.get(group, '^')
            
            # 存储每个点对应的wafer_id，用于交互选择
            wafer_ids = self.transformed_data.loc[mask, self.wafer_id_col].values
            
            ax.plot(sorted_data, norm_quantiles, color=color, marker=marker,
                   linestyle='-', label=group, markersize=6)
        
        # 添加标题和标签
        ax.set_title(f'Normal Quantile Plot - {self.current_parameter}')
        ax.set_xlabel(self.current_parameter)
        ax.set_ylabel('Normal Quantile')
        
        # Y轴使用概率刻度
        prob_ticks = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99]
        quantile_ticks = stats.norm.ppf(prob_ticks)
        ax.set_yticks(quantile_ticks)
        ax.set_yticklabels([f'{p:.2f}' for p in prob_ticks])
        
        # 添加参考线
        ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
        
        # 添加图例
        ax.legend(loc='best')
        
        # 添加网格
        ax.grid(True, alpha=0.3)
        
        # 刷新画布
        self.qq_canvas.draw()

    def enable_selection_mode(self, mode):
        """启用选择模式"""
        # 在当前活跃的选项卡上启用选择
        current_tab_index = self.findChild(QTabWidget).currentIndex()
        
        if current_tab_index == 0:  # Box Plot
            self.box_canvas.enable_selection(mode, self.on_box_selection)
        else:  # QQ Plot
            self.qq_canvas.enable_selection(mode, self.on_qq_selection)

    def on_box_selection(self, indices, line):
        """箱形图选择回调"""
        if not indices.size:
            return
            
        try:
            # 确定哪个组的线被选中
            lines = self.box_fig.axes[0].get_lines()
            line_index = -1
            for i, l in enumerate(lines):
                if l == line:
                    line_index = i
                    break
                    
            if line_index < 0 or line_index >= len(self.box_fig.axes[0].get_xticklabels()):
                return
                
            # 安全获取组名
            tick_labels = self.box_fig.axes[0].get_xticklabels()
            if line_index < len(tick_labels):
                group = tick_labels[line_index].get_text()
            else:
                return
            
            # 获取选中点对应的wafer ID
            mask = self.transformed_data[self.condition_col] == group
            group_data = self.transformed_data.loc[mask, self.current_parameter].dropna()
            wafer_ids = self.transformed_data.loc[mask, self.wafer_id_col].values
            
            # 确保indices不超出范围
            valid_indices = [i for i in indices if i < len(wafer_ids)]
            if not valid_indices:
                return
                
            selected_wafers = [wafer_ids[i] for i in valid_indices]
            
            # 更新排除点
            if self.current_parameter not in self.excluded_points:
                self.excluded_points[self.current_parameter] = []
                
            for wafer_id in selected_wafers:
                self.excluded_points[self.current_parameter].append((group, wafer_id))
                
            # 更新图表
            self.update_plot()
            
            # 提示用户
            QMessageBox.information(self, "选择", f"已排除 {len(selected_wafers)} 个点")
            
        except Exception as e:
            QMessageBox.warning(self, "警告", f"处理选择时出错: {str(e)}")

    def on_qq_selection(self, indices, line):
        """QQ图选择回调"""
        if not indices.size:
            return
            
        try:
            # 获取当前组和参数
            # 确定哪个组的线被选中
            lines = self.qq_fig.axes[0].get_lines()
            line_index = -1
            for i, l in enumerate(lines):
                if l == line:
                    line_index = i
                    break
                    
            if line_index < 0 or line_index >= len(self.condition_types):
                return
                
            # 获取组名
            legends = self.qq_fig.axes[0].get_legend()
            if legends is None:
                return
                
            legend_texts = [text.get_text() for text in legends.get_texts()]
            if line_index >= len(legend_texts):
                return
                
            group = legend_texts[line_index]
            
            # 获取选中点对应的wafer ID
            mask = self.transformed_data[self.condition_col] == group
            group_data = self.transformed_data.loc[mask, self.current_parameter].dropna()
            wafer_ids = self.transformed_data.loc[mask, self.wafer_id_col].values
            
            if len(indices) > len(wafer_ids):
                indices = indices[:len(wafer_ids)]
                
            selected_wafers = [wafer_ids[i] for i in indices]
            
            # 更新排除点
            if self.current_parameter not in self.excluded_points:
                self.excluded_points[self.current_parameter] = []
                
            for wafer_id in selected_wafers:
                self.excluded_points[self.current_parameter].append((group, wafer_id))
                
            # 更新图表
            self.update_plot()
            
            # 提示用户
            QMessageBox.information(self, "选择", f"已排除 {len(selected_wafers)} 个点")
            
        except Exception as e:
            QMessageBox.warning(self, "警告", f"处理选择时出错: {str(e)}")

    def clear_selection(self):
        """清除当前选择"""
        if self.current_parameter in self.excluded_points:
            del self.excluded_points[self.current_parameter]
            self.update_plot()
            QMessageBox.information(self, "清除", f"已清除 {self.current_parameter} 的排除点")

    def clear_excluded_points(self):
        """清除所有排除点"""
        self.excluded_points = {}
        self.update_plot()
        QMessageBox.information(self, "清除", "已清除所有排除点")

    def export_excel(self):
        """导出Excel"""
        if self.transformed_data is None:
            QMessageBox.warning(self, "警告", "没有可导出的数据")
            return
            
        file_name, _ = QFileDialog.getSaveFileName(
            self, "导出Excel", "Wafer_Measurement_Data.xlsx", "Excel Files (*.xlsx)"
        )
        
        if file_name:
            try:
                # 创建一个ExcelWriter对象
                with pd.ExcelWriter(file_name, engine='openpyxl') as writer:
                    # 导出主数据表
                    self.transformed_data.to_excel(writer, sheet_name='Transformed_Data', index=False)
                    
                    # 创建分组数据的表
                    conditions = self.transformed_data[self.condition_col].unique()
                    for condition in conditions:
                        condition_data = self.transformed_data[self.transformed_data[self.condition_col] == condition]
                        # 获取不包含wafer_id和condition列的纯测量数据
                        measure_data = condition_data.drop(columns=[self.wafer_id_col, self.condition_col])
                        
                        # 创建描述性统计信息表
                        stats_df = measure_data.describe().T
                        
                        # 将条件特定数据和统计信息导出到单独的表
                        sheet_name = f"{condition}_Data"[:31]  # Excel表名最长为31个字符
                        condition_data.to_excel(writer, sheet_name=sheet_name, index=False)
                        
                        # 统计信息表
                        stats_sheet_name = f"{condition}_Stats"[:31]
                        stats_df.to_excel(writer, sheet_name=stats_sheet_name)
                
                QMessageBox.information(self, "成功", f"数据已导出到: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"导出Excel时出错: {str(e)}")

    def calculate_statistics(self, parameter, group_col, group_values, jmp_compatible=True):
        """计算统计信息：Mean, Std Dev, K-shift"""
        # 使用去除了排除点的数据
        data = self.transformed_data
        
        stats_dict = {}
        
        for group in group_values:
            group_data = data[data[group_col] == group][parameter].dropna()
            
            # 排除被标记的点
            if parameter in self.excluded_points:
                excluded_wafers = [wafer_id for condition, wafer_id in self.excluded_points[parameter] 
                                  if condition == group]
                if excluded_wafers:
                    # 排除这些wafer的数据
                    exclude_mask = data[self.wafer_id_col].isin(excluded_wafers)
                    group_mask = data[group_col] == group
                    group_data = group_data[~(exclude_mask & group_mask)]
            
            if len(group_data) > 0:
                # 计算均值
                mean_value = np.mean(group_data)
                
                # 计算标准差 - 可以选择兼容JMP的计算方法
                if jmp_compatible:
                    # JMP默认使用样本标准差(n-1)
                    std_dev = np.std(group_data, ddof=1)
                    
                    # 对于小样本(n<30)，JMP可能会使用偏差校正
                    if len(group_data) < 30:
                        # 这是一个简化的偏差校正因子，可能需要根据实际JMP版本调整
                        correction_factor = np.sqrt((len(group_data) - 1) / len(group_data))
                        std_dev *= correction_factor
                else:
                    # 使用标准的样本标准差计算
                    std_dev = np.std(group_data, ddof=1)
                
                stats_dict[group] = {
                    'Mean': mean_value,
                    'Std Dev': std_dev
                }
            else:
                stats_dict[group] = {
                    'Mean': np.nan,
                    'Std Dev': np.nan
                }
        
        # 计算K-shift (如果有两个或更多组)
        if len(group_values) >= 2:
            baseline_group = group_values[0]  # 假设第一个为baseline
            second_tool_group = group_values[1]  # 假设第二个为2nd tool
            
            if (baseline_group in stats_dict and second_tool_group in stats_dict and
                not np.isnan(stats_dict[baseline_group]['Std Dev']) and
                stats_dict[baseline_group]['Std Dev'] != 0):
                
                stats_dict[second_tool_group]['K-shift'] = (
                    stats_dict[second_tool_group]['Mean'] - stats_dict[baseline_group]['Mean']
                ) / stats_dict[baseline_group]['Std Dev']
            else:
                if second_tool_group in stats_dict:
                    stats_dict[second_tool_group]['K-shift'] = np.nan
        
        return stats_dict

    def create_ppt(self):
        """创建PPT报告"""
        if self.transformed_data is None:
            QMessageBox.warning(self, "警告", "没有可导出的数据")
            return
            
        file_name, _ = QFileDialog.getSaveFileName(
            self, "创建PPT", "Wafer_Measurement_Analysis.pptx", "PowerPoint Files (*.pptx)"
        )
        
        if file_name:
            try:
                # 创建演示文稿
                prs = Presentation()
                
                # 设置幻灯片大小为标准尺寸(4:3)
                prs.slide_width = Inches(10)
                prs.slide_height = Inches(7.5)
                
                # 添加空白幻灯片
                blank_slide_layout = prs.slide_layouts[6]  # 空白布局
                slide = prs.slides.add_slide(blank_slide_layout)
                
                # 添加标题 - 位置调高
                title_shape = slide.shapes.add_textbox(Inches(0), Inches(0.1), Inches(10), Inches(0.5))
                title_frame = title_shape.text_frame
                title_para = title_frame.add_paragraph()
                title_para.text = "Wafer Measurement Analysis Report"
                title_para.alignment = PP_ALIGN.CENTER
                title_run = title_para.runs[0]
                title_run.font.size = Pt(20)
                title_run.font.bold = True
                
                # 左侧放置Box Plot
                left_panel_x = Inches(0.2)
                left_panel_y = Inches(0.7)  # 位置调高
                left_panel_width = Inches(3.5)
                left_panel_height = Inches(5.0)
                
                # 右侧放置Quantile Plot (2x3网格)
                right_panel_x = Inches(3.8)
                right_panel_y = Inches(0.7)  # 位置调高
                right_panel_width = Inches(6.0)
                right_panel_height = Inches(5.0)
                
                # 计算单个Box Plot的尺寸
                box_plot_height = left_panel_height / len(self.available_parameters)
                
                # 计算单个Quantile Plot的尺寸
                quantile_plot_width = right_panel_width / 2
                quantile_plot_height = right_panel_height / 3
                
                # 确保Baseline在前，2nd tool在后
                ordered_group_values = []
                for expected_group in ["Baseline", "2nd tool"]:
                    if expected_group in self.condition_types:
                        ordered_group_values.append(expected_group)
                
                # 添加其他可能的组
                for group in self.condition_types:
                    if group not in ordered_group_values:
                        ordered_group_values.append(group)
                
                # 获取正确的基线组和对照组
                baseline_group = ordered_group_values[0]  # 第一个组视为基线
                second_tool_group = ordered_group_values[1] if len(ordered_group_values) > 1 else None
                
                # 获取每个参数的统计数据，用于最后的表格
                all_stats = {}
                
                # 创建左侧Box Plot
                for i, parameter in enumerate(self.available_parameters):
                    # 计算Box Plot位置
                    y_pos = left_panel_y + i * box_plot_height
                    
                    # 创建Box Plot图像
                    fig = Figure(figsize=(4, 1.7), dpi=100)
                    ax = fig.add_subplot(111)
                    
                    # 准备数据
                    box_data = []
                    valid_labels = []
                    
                    for group in ordered_group_values:
                        # 获取组内参数数据
                        mask = self.transformed_data[self.condition_col] == group
                        group_data = self.transformed_data.loc[mask, parameter].dropna()
                        
                        # 排除被标记的点
                        if parameter in self.excluded_points:
                            excluded_wafers = [wafer_id for condition, wafer_id in self.excluded_points[parameter] 
                                            if condition == group]
                            if excluded_wafers:
                                # 排除这些wafer的数据
                                exclude_mask = self.transformed_data[self.wafer_id_col].isin(excluded_wafers)
                                group_data = group_data[~(exclude_mask & mask)]
                        
                        if len(group_data) > 0:
                            box_data.append(group_data)
                            valid_labels.append(group)
                    
                    if not box_data:
                        ax.text(0.5, 0.5, f"无数据可用于 {parameter}", ha='center', va='center', transform=ax.transAxes)
                        continue
                    
                    # 创建箱线图
                    colors = []
                    for label in valid_labels:
                        if label == "Baseline":
                            colors.append('lightblue')
                        elif label == "2nd tool":
                            colors.append('lightgreen')
                        else:
                            colors.append('lightgray')  # 默认颜色
                    
                    boxplot = ax.boxplot(box_data, patch_artist=True, labels=valid_labels)
                    
                    for i, patch in enumerate(boxplot['boxes']):
                        if i < len(colors):
                            patch.set_facecolor(colors[i])
                    
                    # 添加标题
                    ax.set_title(f'Box Plot - {parameter}', fontsize=10)
                    ax.set_ylabel(parameter, fontsize=8)
                    ax.tick_params(axis='both', labelsize=7)
                    
                    fig.tight_layout()
                    
                    # 转换为字节流
                    buf = io.BytesIO()
                    fig.savefig(buf, format='png', bbox_inches='tight')
                    plt.close(fig)
                    buf.seek(0)
                    
                    # 添加到PPT
                    slide.shapes.add_picture(
                        buf, 
                        left_panel_x, 
                        y_pos, 
                        width=left_panel_width
                    )
                    
                    # 计算统计数据
                    stats_dict = self.calculate_statistics(parameter, self.condition_col, ordered_group_values, jmp_compatible=True)
                    all_stats[parameter] = stats_dict
                
                # 创建右侧Quantile Plot (2x3网格)
                grid_positions = [
                    # Col 1
                    (right_panel_x, right_panel_y),                              # Row 1, Col 1
                    (right_panel_x, right_panel_y + quantile_plot_height),       # Row 2, Col 1
                    (right_panel_x, right_panel_y + 2 * quantile_plot_height),   # Row 3, Col 1
                    # Col 2
                    (right_panel_x + quantile_plot_width, right_panel_y),                         # Row 1, Col 2
                    (right_panel_x + quantile_plot_width, right_panel_y + quantile_plot_height),  # Row 2, Col 2
                    (right_panel_x + quantile_plot_width, right_panel_y + 2 * quantile_plot_height) # Row 3, Col 2
                ]
                
                # 最多放置6个Quantile Plot
                for i, parameter in enumerate(self.available_parameters[:6]):
                    # 计算Quantile Plot位置
                    if i < len(grid_positions):
                        x_pos, y_pos = grid_positions[i]
                        
                        # 创建QQ Plot图像
                        fig = Figure(figsize=(2.9, 1.7), dpi=100)
                        ax = fig.add_subplot(111)
                        
                        # 确保Baseline和2nd tool始终是固定颜色
                        color_map = {
                            "Baseline": 'blue',
                            "2nd tool": 'green'
                        }
                        marker_map = {
                            "Baseline": 'o',
                            "2nd tool": 's'
                        }
                        
                        for group in ordered_group_values:
                            # 获取当前组的数据
                            mask = self.transformed_data[self.condition_col] == group
                            group_data = self.transformed_data.loc[mask, parameter].dropna()
                            
                            # 排除被标记的点
                            if parameter in self.excluded_points:
                                excluded_wafers = [wafer_id for condition, wafer_id in self.excluded_points[parameter] 
                                                if condition == group]
                                if excluded_wafers:
                                    # 排除这些wafer的数据
                                    exclude_mask = self.transformed_data[self.wafer_id_col].isin(excluded_wafers)
                                    group_data = group_data[~(exclude_mask & mask)]
                            
                            if len(group_data) == 0:
                                continue
                            
                            # 排序数据
                            sorted_data = np.sort(group_data)
                            n = len(sorted_data)
                            
                            # JMP概率计算公式: (i-0.375)/(n+0.25)
                            probabilities = np.array([(i + 1 - 0.375) / (n + 0.25) for i in range(n)])
                            
                            # 转换为正态分布的分位数
                            norm_quantiles = stats.norm.ppf(probabilities)
                            
                            # 绘制 - 使用对应颜色和标记
                            color = color_map.get(group, 'gray')  # 如果不是预期组，使用灰色
                            marker = marker_map.get(group, '^')
                            
                            ax.plot(sorted_data, norm_quantiles, color=color, marker=marker,
                                   linestyle='-', label=group, markersize=4)
                        
                        # 添加标题
                        ax.set_title(parameter, fontsize=10)
                        
                        # 添加轴标签
                        ax.set_xlabel(parameter, fontsize=8)
                        ax.set_ylabel('Normal Quantile', fontsize=8)
                        
                        # Y轴使用概率刻度
                        prob_ticks = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99]
                        quantile_ticks = stats.norm.ppf(prob_ticks)
                        ax.set_yticks(quantile_ticks)
                        ax.set_yticklabels([f'{p:.2f}' for p in prob_ticks], fontsize=7)
                        ax.tick_params(axis='x', labelsize=7)
                        
                        # 添加参考线
                        ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
                        
                        # 添加图例
                        ax.legend(loc='best', fontsize=7)
                        
                        # 添加网格
                        ax.grid(True, alpha=0.3)
                        
                        fig.tight_layout()
                        
                        # 转换为字节流
                        buf = io.BytesIO()
                        fig.savefig(buf, format='png', bbox_inches='tight')
                        plt.close(fig)
                        buf.seek(0)
                        
                        # 添加到PPT
                        slide.shapes.add_picture(
                            buf, 
                            x_pos, 
                            y_pos, 
                            width=quantile_plot_width
                        )
                
                # 创建底部的统计表格 - 调整位置和大小
                table_rows = len(self.available_parameters) + 2  # 参数数量 + 标题两行
                table_cols = 5  # Condition, BSL Mean, BSL Std Dev, 2nd Tool Mean, K-shift
                
                table = slide.shapes.add_table(
                    table_rows, 
                    table_cols,
                    Inches(0.5), 
                    Inches(5.8),  # 位置略向上调整
                    Inches(9), 
                    Inches(1.5)
                ).table
                
                # 设置列宽
                table.columns[0].width = Inches(2.0)
                for i in range(1, 5):
                    table.columns[i].width = Inches(1.75)
                
                # 添加表头 - 完全符合JMP风格
                header_cells = [
                    "Condition", baseline_group, "", second_tool_group, ""
                ]
                for i, text in enumerate(header_cells):
                    cell = table.cell(0, i)
                    cell.text = text if text is not None else ""
                    # 安全地设置粗体和字体大小
                    para = cell.text_frame.paragraphs[0]
                    para.alignment = PP_ALIGN.CENTER
                    if not para.runs:
                        run = para.add_run()
                        run.text = text if text is not None else ""
                    else:
                        run = para.runs[0]
                    run.font.bold = True
                    run.font.size = Pt(11)
                
                # 第二行表头
                subheader_cells = [
                    "Statistics", "Mean", "Std Dev", "Mean", "K-shift"
                ]
                for i, text in enumerate(subheader_cells):
                    cell = table.cell(1, i)
                    cell.text = text
                    # 安全地设置粗体和字体大小
                    para = cell.text_frame.paragraphs[0]
                    para.alignment = PP_ALIGN.CENTER
                    if not para.runs:
                        run = para.add_run()
                        run.text = text
                    else:
                        run = para.runs[0]
                    run.font.bold = True
                    run.font.size = Pt(11)
                
                # 添加数据行
                for i, parameter in enumerate(self.available_parameters):
                    stats_dict = all_stats.get(parameter, {})
                    
                    if not stats_dict:
                        continue
                        
                    # 准备数据
                    baseline_stats = stats_dict.get(baseline_group, {})
                    second_tool_stats = stats_dict.get(second_tool_group, {}) if second_tool_group else {}
                    
                    # 为小值启用科学记号
                    def format_value(value, param_name):
                        if value is None or np.isnan(value):
                            return 'N/A'
                        
                        # 判断是否为非常小的值 (例如LK类似的量级)
                        if 'LK' in param_name and abs(value) < 0.001:
                            return f"{value:.4e}"  # 使用科学记号
                        elif abs(value) < 0.0001:  # 其他很小的值也使用科学记号
                            return f"{value:.4e}"
                        else:
                            return f"{value:.4f}"  # 常规数值使用固定小数点
                    
                    row_data = [
                        parameter,
                        format_value(baseline_stats.get('Mean', np.nan), parameter) if 'Mean' in baseline_stats else 'N/A',
                        format_value(baseline_stats.get('Std Dev', np.nan), parameter) if 'Std Dev' in baseline_stats else 'N/A',
                        format_value(second_tool_stats.get('Mean', np.nan), parameter) if 'Mean' in second_tool_stats else 'N/A',
                        format_value(second_tool_stats.get('K-shift', np.nan), parameter) if 'K-shift' in second_tool_stats else 'N/A'
                    ]
                    
                    # 填充表格
                    for j, text in enumerate(row_data):
                        cell = table.cell(i + 2, j)
                        cell.text = text
                        para = cell.text_frame.paragraphs[0]
                        para.alignment = PP_ALIGN.CENTER
                        if not para.runs:
                            run = para.add_run()
                            run.text = text
                        else:
                            run = para.runs[0]
                        run.font.size = Pt(10)
                
                # 保存演示文稿
                prs.save(file_name)
                QMessageBox.information(self, "成功", f"已创建PPT文件: {file_name}")
                
            except Exception as e:
                QMessageBox.critical(self, "错误", f"创建PPT时出错: {str(e)}")

    def show_about(self):
        """显示关于对话框"""
        about_text = """
        <h3>晶圆测量分析工具</h3>
        <p>版本: 1.0</p>
        <p>这是一个用于分析晶圆测量数据的工具，支持：</p>
        <ul>
            <li>数据加载和处理</li>
            <li>交互式箱形图和QQ图</li>
            <li>异常值识别和排除</li>
            <li>统计分析</li>
            <li>导出Excel和PPT报告</li>
        </ul>
        <p>&copy; 2023</p>
        """
        QMessageBox.about(self, "关于", about_text)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WaferAnalysisApp()
    window.show()
    sys.exit(app.exec())

import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
import io
import traceback
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qtagg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
from matplotlib.widgets import LassoSelector, RectangleSelector
from matplotlib.path import Path

from PyQt6.QtWidgets import (QApplication, QMainWindow, QPushButton, QVBoxLayout, QHBoxLayout,
                           QWidget, QTableView, QHeaderView, QLabel, QComboBox, QFileDialog,
                           QMessageBox, QSplitter, QTabWidget, QGroupBox)
from PyQt6.QtCore import Qt, QAbstractTableModel, QModelIndex
from PyQt6.QtGui import QAction
from datetime import datetime
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor



# 用于在QTableView中显示pandas DataFrame的自定义模型
class PandasModel(QAbstractTableModel):
    def __init__(self, data=None):
        super().__init__()
        self._data = pd.DataFrame() if data is None else data

    def rowCount(self, parent=QModelIndex()):
        return self._data.shape[0]

    def columnCount(self, parent=QModelIndex()):
        return self._data.shape[1]

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None

        if role == Qt.ItemDataRole.DisplayRole:
            value = self._data.iloc[index.row(), index.column()]
            # 处理特殊值的显示
            if pd.isna(value):
                return ""
            elif isinstance(value, (float, np.float64)):
                if abs(value) < 0.0001:
                    return f"{value:.4e}"
                else:
                    return f"{value:.4f}"
            else:
                return str(value)

        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                return str(self._data.columns[section])
            else:
                return str(section + 1)
        return None

    def setData(self, data):
        self._data = data
        self.layoutChanged.emit()


# 自定义的Figure Canvas，支持交互式选择
class InteractiveFigureCanvas(FigureCanvas):
    def __init__(self, fig, parent=None):
        super().__init__(fig)
        self.setParent(parent)
        self.figure = fig
        self.selected_points = []
        self.wafer_ids = []
        self.selector = None
        self.callback = None

    def enable_selection(self, mode='rectangle', callback=None):
        """启用选择模式，可以是'rectangle'或'lasso'"""
        if self.figure.axes:
            ax = self.figure.axes[0]
            self.callback = callback

            if mode == 'rectangle':
                self.selector = RectangleSelector(
                    ax, self.on_select, useblit=True,
                    button=[1], minspanx=5, minspany=5,
                    spancoords='pixels', interactive=True
                )
            elif mode == 'lasso':
                self.selector = LassoSelector(
                    ax, self.on_select_lasso, useblit=True
                )

    def disable_selection(self):
        """禁用选择模式"""
        if self.selector:
            self.selector.set_active(False)
            self.selector = None

    def on_select(self, eclick, erelease):
        """矩形选择回调"""
        if not self.figure.axes:
            return

        ax = self.figure.axes[0]
        x1, y1 = eclick.xdata, eclick.ydata
        x2, y2 = erelease.xdata, erelease.ydata

        # 获取所有点的坐标
        for line in ax.get_lines():
            xdata = line.get_xdata()
            ydata = line.get_ydata()

            # 找出在选择区域内的点
            selected_indices = np.where(
                (xdata >= min(x1, x2)) & (xdata <= max(x1, x2)) &
                (ydata >= min(y1, y2)) & (ydata <= max(y1, y2))
            )[0]

            if len(selected_indices) > 0 and self.callback:
                self.callback(selected_indices, line)
                
        # 选择完成后自动禁用选择器
        self.disable_selection()

    def on_select_lasso(self, verts):
        """套索选择回调"""
        if not self.figure.axes:
            return

        ax = self.figure.axes[0]
        path = Path(verts)

        # 获取所有点的坐标
        for line in ax.get_lines():
            xdata = line.get_xdata()
            ydata = line.get_ydata()
            coords = np.column_stack([xdata, ydata])

            # 找出在套索区域内的点
            selected_indices = np.where(path.contains_points(coords))[0]

            if len(selected_indices) > 0 and self.callback:
                self.callback(selected_indices, line)
                
        # 选择完成后自动禁用选择器
        self.disable_selection()


class WaferAnalysisApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("晶圆测量分析工具")
        self.setGeometry(100, 100, 1280, 800)

        # 数据存储
        self.query_data = None
        self.condition_data = None
        self.transformed_data = None
        self.display_data = None  # 用于显示的数据副本，可以排除异常值
        self.wafer_id_col = None
        self.condition_col = None
        self.site_col = None
        self.available_parameters = []
        self.condition_types = []
        self.current_parameter = None
        self.excluded_points = {}  # 存储被排除的点 {parameter: [(condition, wafer_id, site_id), ...]}
        self.temp_selected_points = {}  # 临时存储被选中的点，等待确认
        self.operation_history = []  # 用于存储操作历史，支持撤销功能

        # 设置菜单栏
        self.create_menu_bar()

        # 设置UI
        self.setup_ui()

    def create_menu_bar(self):
        menu_bar = self.menuBar()

        # 文件菜单
        file_menu = menu_bar.addMenu("文件")

        # 打开查询数据
        open_query_action = QAction("打开查询数据", self)
        open_query_action.triggered.connect(self.load_query_data)
        file_menu.addAction(open_query_action)

        # 打开条件数据
        open_cond_action = QAction("打开条件数据", self)
        open_cond_action.triggered.connect(self.load_condition_data)
        file_menu.addAction(open_cond_action)

        file_menu.addSeparator()

        # 导出Excel
        export_excel_action = QAction("导出Excel", self)
        export_excel_action.triggered.connect(self.export_excel)
        file_menu.addAction(export_excel_action)

        # 创建PPT
        create_ppt_action = QAction("创建PPT报告", self)
        create_ppt_action.triggered.connect(self.create_ppt)
        file_menu.addAction(create_ppt_action)

        file_menu.addSeparator()

        # 退出
        exit_action = QAction("退出", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # 数据菜单
        data_menu = menu_bar.addMenu("数据")

        # 处理数据
        process_action = QAction("处理数据", self)
        process_action.triggered.connect(self.process_data)
        data_menu.addAction(process_action)

        # 清除排除点
        clear_exclude_action = QAction("清除排除点", self)
        clear_exclude_action.triggered.connect(self.clear_excluded_points)
        data_menu.addAction(clear_exclude_action)

        # 帮助菜单
        help_menu = menu_bar.addMenu("帮助")

        # 关于
        about_action = QAction("关于", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

    # 更新的主UI函数，添加wafer散点图面板(续)
    def setup_ui(self):
        """设置UI布局 - 改进版本"""
        # 主布局
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # 顶部控制区域
        top_controls = QWidget()
        top_layout = QHBoxLayout(top_controls)

        # 文件上传区域
        file_group = QGroupBox("数据文件")
        file_layout = QHBoxLayout(file_group)

        self.query_btn = QPushButton("上传查询数据")
        self.condition_btn = QPushButton("上传条件数据")
        self.process_btn = QPushButton("处理数据")

        self.query_btn.clicked.connect(self.load_query_data)
        self.condition_btn.clicked.connect(self.load_condition_data)
        self.process_btn.clicked.connect(self.process_data)

        file_layout.addWidget(self.query_btn)
        file_layout.addWidget(self.condition_btn)
        file_layout.addWidget(self.process_btn)

        # 参数选择区域
        param_group = QGroupBox("参数选择")
        param_layout = QHBoxLayout(param_group)

        param_label = QLabel("选择参数:")
        self.param_combo = QComboBox()
        self.param_combo.currentIndexChanged.connect(self.on_parameter_changed)
        
        param_layout.addWidget(param_label)
        param_layout.addWidget(self.param_combo)

        # 导出区域
        export_group = QGroupBox("导出")
        export_layout = QHBoxLayout(export_group)

        self.export_excel_btn = QPushButton("导出Excel")
        self.export_ppt_btn = QPushButton("创建PPT")
        
        self.export_excel_btn.clicked.connect(self.export_excel)
        self.export_ppt_btn.clicked.connect(self.create_ppt)
        
        export_layout.addWidget(self.export_excel_btn)
        export_layout.addWidget(self.export_ppt_btn)

        # 添加到顶部布局
        top_layout.addWidget(file_group)
        top_layout.addWidget(param_group)
        top_layout.addWidget(export_group)

        # 主分割窗口
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # 左侧数据表格和统计信息
        table_widget = QWidget()
        table_layout = QVBoxLayout(table_widget)
        
        # 添加数据表格和统计信息的垂直分割
        table_splitter = QSplitter(Qt.Orientation.Vertical)
        
        # 上部分：数据表格
        table_upper = QWidget()
        table_upper_layout = QVBoxLayout(table_upper)
        table_label = QLabel("数据表格")
        self.table_view = QTableView()
        self.table_model = PandasModel()
        self.table_view.setModel(self.table_model)
        
        table_upper_layout.addWidget(table_label)
        table_upper_layout.addWidget(self.table_view)
        
        # 下部分：统计信息
        table_lower = QWidget()
        table_lower_layout = QVBoxLayout(table_lower)
        stats_label = QLabel("统计结果")
        self.stats_view = QTableView()
        self.stats_model = PandasModel()
        self.stats_view.setModel(self.stats_model)
        
        table_lower_layout.addWidget(stats_label)
        table_lower_layout.addWidget(self.stats_view)
        
        # 添加到分割器
        table_splitter.addWidget(table_upper)
        table_splitter.addWidget(table_lower)
        table_splitter.setSizes([600, 200])  # 设置初始比例
        
        table_layout.addWidget(table_splitter)
        
        # 右侧图表区域
        plot_widget = QWidget()
        plot_layout = QVBoxLayout(plot_widget)
        
        # 创建选项卡窗口用于不同图表
        tab_widget = QTabWidget()
        
        # Box Plot 选项卡
        self.box_tab = QWidget()
        box_layout = QVBoxLayout(self.box_tab)
        
        self.box_fig = Figure(figsize=(5, 4), dpi=100)
        self.box_canvas = InteractiveFigureCanvas(self.box_fig)
        self.box_toolbar = NavigationToolbar(self.box_canvas, self.box_tab)
        
        box_layout.addWidget(self.box_toolbar)
        box_layout.addWidget(self.box_canvas)
        
        # QQ Plot 选项卡
        self.qq_tab = QWidget()
        qq_layout = QVBoxLayout(self.qq_tab)
        
        self.qq_fig = Figure(figsize=(5, 4), dpi=100)
        self.qq_canvas = InteractiveFigureCanvas(self.qq_fig)
        self.qq_toolbar = NavigationToolbar(self.qq_canvas, self.qq_tab)
        
        qq_layout.addWidget(self.qq_toolbar)
        qq_layout.addWidget(self.qq_canvas)
        
        # Wafer ID散点图选项卡 (新增)
        self.wafer_tab = QWidget()
        wafer_layout = QVBoxLayout(self.wafer_tab)
        
        self.wafer_fig = Figure(figsize=(5, 4), dpi=100)
        self.wafer_canvas = FigureCanvas(self.wafer_fig)
        self.wafer_toolbar = NavigationToolbar(self.wafer_canvas, self.wafer_tab)
        
        wafer_layout.addWidget(self.wafer_toolbar)
        wafer_layout.addWidget(self.wafer_canvas)
        
        # 添加选项卡
        tab_widget.addTab(self.box_tab, "箱形图")
        tab_widget.addTab(self.qq_tab, "Q-Q图")
        tab_widget.addTab(self.wafer_tab, "Wafer散点图")  # 新增选项卡
        
        plot_layout.addWidget(tab_widget)
        
        # 右下方控制区域
        plot_controls = QWidget()
        plot_controls_layout = QHBoxLayout(plot_controls)
        
        self.rect_select_btn = QPushButton("矩形选择")
        self.lasso_select_btn = QPushButton("套索选择")
        self.confirm_select_btn = QPushButton("确认删除")
        self.clear_select_btn = QPushButton("清除选择")
        self.undo_select_btn = QPushButton("上一步")
        
        self.rect_select_btn.clicked.connect(lambda: self.enable_selection_mode('rectangle'))
        self.lasso_select_btn.clicked.connect(lambda: self.enable_selection_mode('lasso'))
        self.confirm_select_btn.clicked.connect(self.confirm_selection)
        self.clear_select_btn.clicked.connect(self.clear_selection)
        self.undo_select_btn.clicked.connect(self.undo_selection)
        
        plot_controls_layout.addWidget(self.rect_select_btn)
        plot_controls_layout.addWidget(self.lasso_select_btn)
        plot_controls_layout.addWidget(self.confirm_select_btn)
        plot_controls_layout.addWidget(self.clear_select_btn)
        plot_controls_layout.addWidget(self.undo_select_btn)
        
        plot_layout.addWidget(plot_controls)
        
        # 添加到分割窗口
        splitter.addWidget(table_widget)
        splitter.addWidget(plot_widget)
        splitter.setSizes([400, 800])  # 设置初始大小比例
        
        # 添加到主布局
        main_layout.addWidget(top_controls)
        main_layout.addWidget(splitter, 1)  # 1表示拉伸因子

        # 初始状态设置
        self.export_excel_btn.setEnabled(False)
        self.export_ppt_btn.setEnabled(False)
        self.param_combo.setEnabled(False)
        self.rect_select_btn.setEnabled(False)
        self.lasso_select_btn.setEnabled(False)
        self.confirm_select_btn.setEnabled(False)  # 初始状态禁用确认按钮
        self.clear_select_btn.setEnabled(False)
        self.undo_select_btn.setEnabled(False)

    # 更新图表的函数
    def update_plot(self, mark_only=False):
        """更新所有图表"""
        if self.transformed_data is None or self.current_parameter is None:
            return
            
        # 如果是首次加载或切换参数且不是仅标记模式，创建显示数据副本
        if (self.display_data is None or self.current_parameter not in self.excluded_points) and not mark_only:
            self.display_data = self.transformed_data.copy()
        
        # 更新箱形图
        self.update_box_plot(mark_only)
        
        # 更新QQ图
        self.update_qq_plot(mark_only)
        
        # 更新Wafer散点图 (新增)
        if not mark_only:  # 仅在非标记模式下更新
            self.update_wafer_scatter_plot(self.wafer_fig, self.current_parameter)
            self.wafer_canvas.draw()


    def load_query_data(self):
        """加载查询数据文件"""
        file_name, _ = QFileDialog.getOpenFileName(
            self, "选择查询数据文件", "", "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        
        if file_name:
            try:
                if file_name.endswith('.csv'):
                    self.query_data = pd.read_csv(file_name)
                else:
                    self.query_data = pd.read_excel(file_name)
                
                QMessageBox.information(self, "成功", f"已加载查询数据: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"加载数据时出错: {str(e)}")

    def load_condition_data(self):
        """加载条件数据文件"""
        file_name, _ = QFileDialog.getOpenFileName(
            self, "选择条件数据文件", "", "Excel Files (*.xlsx *.xls);;CSV Files (*.csv);;All Files (*)"
        )
        
        if file_name:
            try:
                if file_name.endswith('.csv'):
                    self.condition_data = pd.read_csv(file_name)
                else:
                    self.condition_data = pd.read_excel(file_name)
                
                QMessageBox.information(self, "成功", f"已加载条件数据: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"加载数据时出错: {str(e)}")

    def process_data(self):
        """处理数据"""
        if self.query_data is None or self.condition_data is None:
            if self.query_data is None and self.condition_data is None:
                # 如果两个数据都未加载，创建模拟数据
                self.create_sample_data()
            else:
                QMessageBox.warning(self, "警告", "请先加载查询数据和条件数据")
                return
        
        try:
            # 处理数据
            transformed_data, condition_types, measure_parameters, wafer_id_col, condition_col, site_col = self.transform_data()
            
            if transformed_data is not None:
                self.transformed_data = transformed_data
                # 创建一个副本用于图表显示，以便在不改变原始数据的情况下移除异常值
                self.display_data = transformed_data.copy()
                self.condition_types = condition_types
                self.wafer_id_col = wafer_id_col
                self.condition_col = condition_col
                self.site_col = site_col
                
                # 清除排除点和临时选择
                self.excluded_points = {}
                self.temp_selected_points = {}
                # 添加历史操作记录，用于"上一步"功能
                self.operation_history = []
                
                # 更新可用参数
                self.available_parameters = []
                for param in measure_parameters:
                    if param in transformed_data.columns:
                        self.available_parameters.append(param)
                
                if len(self.available_parameters) == 0:
                    # 如果没有找到可用参数，尝试使用非ID和非条件列
                    for col in transformed_data.columns:
                        if "wafer" not in col.lower() and col != condition_col and col != site_col:
                            self.available_parameters.append(col)
                
                # 更新UI
                self.update_parameter_combo()
                self.update_table_view()
                
                # 启用功能按钮
                self.export_excel_btn.setEnabled(True)
                self.export_ppt_btn.setEnabled(True)
                self.param_combo.setEnabled(True)
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                self.clear_select_btn.setEnabled(True)
                self.confirm_select_btn.setEnabled(False)  # 初始没有选择，禁用确认按钮
                self.undo_select_btn.setEnabled(False)  # 初始没有操作，禁用上一步
                
                QMessageBox.information(self, "成功", "数据处理完成")
            else:
                QMessageBox.warning(self, "警告", "数据处理失败")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"处理数据时出错: {str(e)}\n{traceback.format_exc()}")

    def transform_data(self):
        """转换数据，合并查询数据和条件数据，保留Site ID和添加WAT Date信息"""
        try:
            # 查找查询数据中的Wafer ID列
            wafer_id_query = "Wafer ID" if "Wafer ID" in self.query_data.columns else "WaferID"
            if wafer_id_query not in self.query_data.columns:
                # 寻找可能包含wafer id的列
                for col in self.query_data.columns:
                    if "wafer" in col.lower():
                        wafer_id_query = col
                        break
            
            # 查找条件数据中的WaferID列
            wafer_id_condition = "WaferID" if "WaferID" in self.condition_data.columns else "Wafer ID"
            if wafer_id_condition not in self.condition_data.columns:
                # 寻找可能包含wafer id的列
                for col in self.condition_data.columns:
                    if "wafer" in col.lower():
                        wafer_id_condition = col
                        break
            
            # 查找参数名列、值列和Site ID列
            parameter_col = None
            value_col = None
            site_col = None
            date_col = None  # 添加日期列
            
            for col in self.query_data.columns:
                if "parameter name" in col.lower() or "name" in col.lower():
                    parameter_col = col
                elif "value" in col.lower():
                    value_col = col
                elif "site" in col.lower() and "value" not in col.lower():
                    site_col = col
                elif "date" in col.lower() or "time" in col.lower():
                    date_col = col
            
            # 查找条件列
            condition_col = None
            for col in self.condition_data.columns:
                if "condition" in col.lower():
                    condition_col = col
                    break
            
            # 获取条件类型（通常是Baseline和2nd tool）
            if condition_col and condition_col in self.condition_data.columns:
                condition_types = self.condition_data[condition_col].unique()
            else:
                condition_types = ["Baseline", "2nd tool"]
            
            # 获取参数列表
            if parameter_col and parameter_col in self.query_data.columns:
                measure_parameters = self.query_data[parameter_col].unique()
            else:
                measure_parameters = ["Con_M3LA", "Con_M3LB", "Rc_V2v", "LK_M3LA", "LK_M3LB"]
            
            # 合并数据
            merged_data = pd.merge(
                self.query_data,
                self.condition_data,
                left_on=wafer_id_query,
                right_on=wafer_id_condition,
            )
            
            # 处理和规范化日期信息
            if date_col and date_col in merged_data.columns:
                # 尝试转换日期格式
                try:
                    merged_data['WAT_Date'] = pd.to_datetime(merged_data[date_col])
                    merged_data['WAT_Date'] = merged_data['WAT_Date'].dt.strftime('%Y-%m-%d')
                except:
                    # 如果无法转换，创建一个虚拟日期列
                    print("无法转换日期列，创建虚拟WAT_Date")
                    # 根据Wafer ID分组创建虚拟日期
                    unique_wafers = merged_data[wafer_id_query].unique()
                    wafer_dates = {}
                    base_date = datetime.now()
                    
                    for i, wafer_id in enumerate(unique_wafers):
                        # 为每个Wafer ID分配一个不同的日期，向前推几天
                        wafer_dates[wafer_id] = (base_date - pd.Timedelta(days=i)).strftime('%Y-%m-%d')
                    
                    merged_data['WAT_Date'] = merged_data[wafer_id_query].map(wafer_dates)
            else:
                # 如果没有日期列，创建一个虚拟日期列
                print("未找到日期列，创建虚拟WAT_Date")
                # 根据Wafer ID分组创建虚拟日期
                unique_wafers = merged_data[wafer_id_query].unique()
                wafer_dates = {}
                base_date = datetime.now()
                
                for i, wafer_id in enumerate(unique_wafers):
                    # 为每个Wafer ID分配一个不同的日期，向前推几天
                    wafer_dates[wafer_id] = (base_date - pd.Timedelta(days=i)).strftime('%Y-%m-%d')
                
                merged_data['WAT_Date'] = merged_data[wafer_id_query].map(wafer_dates)
            
            # 使用Site ID创建透视表
            try:
                # 准备包含Site ID和WAT Date的数据转换
                if site_col:
                    # 使用Site ID进行透视
                    pivot_data = merged_data.pivot_table(
                        index=[wafer_id_query, site_col, condition_col, 'WAT_Date'],
                        columns=parameter_col,
                        values=value_col,
                    ).reset_index()
                else:
                    # 如果找不到Site ID列，创建一个虚拟的
                    merged_data['Site_ID'] = merged_data.groupby([wafer_id_query, parameter_col]).cumcount() + 1
                    site_col = 'Site_ID'
                    
                    pivot_data = merged_data.pivot_table(
                        index=[wafer_id_query, site_col, condition_col, 'WAT_Date'],
                        columns=parameter_col,
                        values=value_col,
                        aggfunc='first'
                    ).reset_index()
                
                print(f"数据透视表形状: {pivot_data.shape}")
                
                return pivot_data, condition_types, measure_parameters, wafer_id_query, condition_col, site_col
                
            except Exception as e:
                print(f"创建数据透视表时出错: {e}")
                
                # 备用方法 - 不使用透视表，直接重塑数据
                transformed_data = merged_data[[wafer_id_query, condition_col, 'WAT_Date']].drop_duplicates()
                
                if site_col:
                    site_data = merged_data[[wafer_id_query, site_col]].drop_duplicates()
                    transformed_data = pd.merge(transformed_data, site_data, on=wafer_id_query, how='left')
                else:
                    # 创建虚拟Site ID
                    merged_data['Site_ID'] = merged_data.groupby(wafer_id_query).cumcount() + 1
                    site_col = 'Site_ID'
                    site_data = merged_data[[wafer_id_query, site_col]].drop_duplicates()
                    transformed_data = pd.merge(transformed_data, site_data, on=wafer_id_query, how='left')
                
                # 为每个参数创建列
                for param in measure_parameters:
                    param_data = merged_data[merged_data[parameter_col] == param]
                    param_data = param_data[[wafer_id_query, site_col, value_col]].rename(columns={value_col: param})
                    transformed_data = pd.merge(transformed_data, param_data, on=[wafer_id_query, site_col], how='left')
                
                print(f"备用转换数据形状: {transformed_data.shape}")
                
                return transformed_data, condition_types, measure_parameters, wafer_id_query, condition_col, site_col
        
        except Exception as e:
            print(f"转换数据时出错: {e}")
            return None, None, None, None, None, None

    # 创建测试数据集（增强版本 - 包含日期信息）
    def create_sample_data(self):
        """创建更真实的模拟数据集，包含Site ID和WAT Date信息"""
        n_wafers = 30
        
        # 创建wafer IDs
        wafer_ids = [f'Wafer_{i:03d}' for i in range(1, n_wafers+1)]
        
        # 条件类型
        condition_types = ['Baseline', '2nd tool']
        
        # 创建WAT日期 - 每3个wafer使用相同的日期
        base_date = datetime.now()
        wafer_dates = {}
        
        for i, wafer_id in enumerate(wafer_ids):
            day_offset = i // 3  # 每3个wafer使用相同的日期
            wafer_dates[wafer_id] = (base_date - pd.Timedelta(days=day_offset)).strftime('%Y-%m-%d')
        
        # 创建条件数据
        condition_data = pd.DataFrame({
            'WaferID': wafer_ids,
            'Condition': np.random.choice(condition_types, size=n_wafers),
            'WAT_Date': [wafer_dates[wid] for wid in wafer_ids]
        })
        
        # 参数名称和典型值范围
        param_specs = {
            'Con_M3LA': (1.5, 2.5),  # 电容参数 - 单位为pF
            'Con_M3LB': (1.5, 2.5),
            'Rc_V2v': (50, 60),     # 电阻参数 - 单位为ohm
            'LK_M3LA': (1e-13, 5e-13),  # 漏电流参数 - 非常小的值
            'LK_M3LB': (1e-13, 5e-13)
        }
        
        # 创建量测数据
        rows = []
        
        for wafer_id in wafer_ids:
            condition = condition_data[condition_data['WaferID'] == wafer_id]['Condition'].values[0]
            wat_date = wafer_dates[wafer_id]
            
            for param_name, (min_val, max_val) in param_specs.items():
                # 为每个wafer和每个参数创建多个site测量
                n_sites = np.random.randint(3, 6)  # 每个wafer有3-5个测量site
                
                # 根据条件微调基准值
                if condition == 'Baseline':
                    base_adjustment = 1.0
                else:
                    # 2nd tool有轻微的偏移
                    if 'Con' in param_name:
                        base_adjustment = np.random.uniform(0.95, 1.05)
                    elif 'Rc' in param_name:
                        base_adjustment = np.random.uniform(0.97, 1.03)
                    else:  # LK参数
                        base_adjustment = np.random.uniform(0.9, 1.1)
                
                for site in range(1, n_sites+1):
                    # 根据参数类型设置基准值
                    base_value = np.random.uniform(min_val, max_val) * base_adjustment
                    
                    # 添加一些随机变异
                    if 'LK' in param_name:  # 漏电流参数有更大的随机性
                        variation = np.random.uniform(0.7, 1.3)
                    else:
                        variation = np.random.uniform(0.95, 1.05)
                    
                    value = base_value * variation
                    
                    # 5%的概率生成异常值
                    if np.random.random() < 0.05:
                        if 'LK' in param_name:
                            value = value * np.random.uniform(3, 10)  # 漏电流异常更明显
                        else:
                            value = value * np.random.uniform(2, 4)
                    
                    rows.append({
                        'Wafer ID': wafer_id,
                        'Parameter Name': param_name,
                        'Site': f'Site_{site}',
                        'Site Value': value,
                        'WAT_Date': wat_date
                    })
        
        query_data = pd.DataFrame(rows)
        
        self.query_data = query_data
        self.condition_data = condition_data
        
        QMessageBox.information(self, "提示", "已创建模拟数据")

    def update_parameter_combo(self):
        if not self.available_parameters:
            return
        
        # 清除当前选项
        self.param_combo.clear()
        
        # 添加参数选项
        for param in self.available_parameters:
            self.param_combo.addItem(param)
        
        # 默认选择第一个参数
        if self.param_combo.count() > 0:
            self.current_parameter = self.available_parameters[0]
            self.update_plot()
            self.update_stats_view()  # 更新统计信息表

    def update_table_view(self):
        """更新数据表格视图"""
        if self.transformed_data is not None:
            self.table_model.setData(self.transformed_data)
            
            # 自动调整列宽
            header = self.table_view.horizontalHeader()
            for i in range(self.table_model.columnCount()):
                header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)

    def calculate_statistics(self, parameter, group_col, group_values, excluded_points=None):
        """计算统计信息：Mean, Std Dev, K-shift，直接使用所有site的数据"""
        stats_dict = {}
        
        for group in group_values:
            # 获取该组的所有数据(所有site，不做wafer平均)
            mask = self.transformed_data[group_col] == group
            group_data = self.transformed_data.loc[mask, parameter].dropna()
            
            # 排除被标记的点
            if excluded_points and parameter in excluded_points:
                exclude_points = excluded_points[parameter]
                for ex_group, ex_wafer_id, ex_site_id in exclude_points:
                    if ex_group == group:
                        # 排除特定wafer和site的点
                        wafer_mask = self.transformed_data[self.wafer_id_col] == ex_wafer_id
                        site_mask = self.transformed_data[self.site_col] == ex_site_id
                        exclude_mask = wafer_mask & site_mask & mask
                        group_data = group_data[~exclude_mask.reindex(group_data.index, fill_value=False)]
            
            if len(group_data) > 0:
                # 计算均值
                mean_value = np.mean(group_data)
                # 计算标准差
                std_dev = np.std(group_data, ddof=1)
                # 计算样本数量
                sample_count = len(group_data)
                
                stats_dict[group] = {
                    'Mean': mean_value,
                    'Std Dev': std_dev,
                    'Count': sample_count
                }
            else:
                stats_dict[group] = {
                    'Mean': np.nan,
                    'Std Dev': np.nan,
                    'Count': 0
                }
        
        # 找出基准组和测试组
        baseline_group = None
        second_tool_group = None
        
        # 首先尝试通过名称识别基准组
        for group in group_values:
            if 'base' in group.lower() or 'baseline' in group.lower() or 'bsl' in group.lower():
                baseline_group = group
                break
        
        # 如果没找到基准组，默认使用第一个组
        if baseline_group is None and len(group_values) > 0:
            baseline_group = group_values[0]
        
        # 识别测试组（非基准组）
        for group in group_values:
            if group != baseline_group:
                second_tool_group = group
                break
        
        # 计算K-shift (如果有两个或更多组)
        if len(group_values) >= 2 and baseline_group and second_tool_group:
            if (baseline_group in stats_dict and second_tool_group in stats_dict and
                not np.isnan(stats_dict[baseline_group]['Std Dev']) and
                stats_dict[baseline_group]['Std Dev'] != 0):
                
                # 计算K-shift
                k_shift = (
                    stats_dict[second_tool_group]['Mean'] - stats_dict[baseline_group]['Mean']
                ) / stats_dict[baseline_group]['Std Dev']
                
                stats_dict[second_tool_group]['K-shift'] = k_shift
            else:
                if second_tool_group in stats_dict:
                    stats_dict[second_tool_group]['K-shift'] = np.nan
        
        return stats_dict, baseline_group, second_tool_group

    # 添加功能：检查所有K-shift是否都小于1.5
    def check_all_kshift_less_than_threshold(self, threshold=1.5):
        """检查所有参数的K-shift是否都小于阈值"""
        all_within_threshold = True
        k_shift_values = {}
        
        for parameter in self.available_parameters:
            stats_dict, baseline_group, second_tool_group = self.calculate_statistics(
                parameter,
                self.condition_col,
                self.condition_types,
                self.excluded_points
            )
            
            if second_tool_group in stats_dict and 'K-shift' in stats_dict[second_tool_group]:
                k_shift = stats_dict[second_tool_group]['K-shift']
                k_shift_values[parameter] = k_shift
                
                if not np.isnan(k_shift) and abs(k_shift) >= threshold:
                    all_within_threshold = False
        
        return all_within_threshold, k_shift_values    


    def update_stats_view(self):
        """更新统计信息表格"""
        if self.transformed_data is None or self.current_parameter is None:
            return
                
        # 计算统计信息 - 注意这里现在返回的是一个元组
        stats_result = self.calculate_statistics(
            self.current_parameter,
            self.condition_col,
            self.condition_types,
            self.excluded_points
        )
        
        # 解包返回值
        stats_dict, baseline_group, second_tool_group = stats_result
        
        # 创建统计信息DataFrame
        stats_rows = []
        for group, stats in stats_dict.items():
            row = {'Condition': group}
            row.update(stats)
            stats_rows.append(row)
        
        stats_df = pd.DataFrame(stats_rows)
        
        # 如果存在，添加K-shift列
        if len(stats_rows) > 1 and 'K-shift' in stats_rows[1]:
            # 确保K-shift列在最后
            cols = [col for col in stats_df.columns if col != 'K-shift']
            if 'K-shift' in stats_df.columns:
                cols.append('K-shift')
            stats_df = stats_df[cols]
        
        # 更新统计表模型
        self.stats_model.setData(stats_df)
        
        # 自动调整列宽
        header = self.stats_view.horizontalHeader()
        for i in range(self.stats_model.columnCount()):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)

    # 增强的参数更改函数
    def on_parameter_changed(self, index):
        """当参数选择改变时调用"""
        if index >= 0 and index < len(self.available_parameters):
            self.current_parameter = self.available_parameters[index]
            # 清除临时选择的点
            self.temp_selected_points = {}
            self.confirm_select_btn.setEnabled(False)
            
            # 更新图表
            self.update_plot()
            
            # 更新统计视图
            self.update_stats_view()
            
            # 更新结果摘要 (如果要添加此功能)
            self.check_all_kshift_less_than_threshold()


    # 更新的Wafer ID散点图函数（续）
    def update_wafer_scatter_plot(self, figure, parameter):
        """创建按Wafer ID的散点图，按WAT Date分组"""
        # 清除当前图表
        figure.clear()
        ax = figure.add_subplot(111)
        
        if self.transformed_data is None or parameter is None:
            ax.text(0.5, 0.5, "无数据可用", ha='center', va='center', transform=ax.transAxes)
            return
        
        # 获取数据
        data = self.display_data.copy()
        
        # 按WAT_Date分组
        unique_dates = sorted(data['WAT_Date'].unique())
        
        # 颜色映射
        colors = plt.cm.tab10.colors
        
        # 按日期和条件绘制散点图
        for date_idx, date in enumerate(unique_dates):
            date_mask = data['WAT_Date'] == date
            date_color = colors[date_idx % len(colors)]
            
            for group_idx, group in enumerate(self.condition_types):
                group_mask = data[self.condition_col] == group
                
                # 获取符合条件的数据
                plot_data = data[date_mask & group_mask]
                
                if len(plot_data) > 0:
                    # 获取唯一的wafer ids
                    wafer_ids = plot_data[self.wafer_id_col].unique()
                    
                    # 为每个wafer id创建x坐标
                    x_coords = []
                    y_values = []
                    
                    for i, wafer_id in enumerate(wafer_ids):
                        wafer_mask = plot_data[self.wafer_id_col] == wafer_id
                        wafer_data = plot_data[wafer_mask]
                        
                        # 为每个wafer添加所有site的数据点
                        for _, row in wafer_data.iterrows():
                            x_coords.append(i + (0.1 if group == 'Baseline' else -0.1))  # 微调x位置以区分组
                            y_values.append(row[parameter])
                    
                    # 绘制散点图
                    marker = 'o' if group == 'Baseline' else 's'
                    ax.scatter(
                        x_coords,
                        y_values,
                        color=date_color,
                        marker=marker,
                        s=30,  # 点的大小
                        alpha=0.7,
                        label=f"{date} - {group}" if date_idx * len(self.condition_types) + group_idx < 10 else None  # 限制图例项数
                    )
        
        # 添加标题和标签
        ax.set_title(f'{parameter} by Wafer ID', fontsize=10)
        ax.set_xlabel('Wafer Index', fontsize=8)
        ax.set_ylabel(parameter, fontsize=8)
        
        # 添加网格线
        ax.grid(True, alpha=0.3)
        
        # 添加图例（如果有多组数据）
        if len(unique_dates) > 0:
            ax.legend(loc='best', fontsize=8)
        
        # 适应坐标轴范围
        ax.margins(0.1)
        
        # 刷新画布
        figure.tight_layout()



    # 修改后的更新箱形图函数
    def update_box_plot(self, mark_only=False):
        """更新箱形图"""
        # 清除当前图表
        self.box_fig.clear()
        ax = self.box_fig.add_subplot(111)
        
        # 使用所有site数据，不做wafer平均
        plot_data = self.display_data.copy()
        
        # 确保Baseline总是第一个，2nd tool总是第二个
        ordered_groups = []
        for expected_group in ["Baseline", "2nd tool"]:
            if expected_group in self.condition_types:
                ordered_groups.append(expected_group)
        
        # 如果有其他不在预期内的组，也添加进来
        for group in self.condition_types:
            if group not in ordered_groups:
                ordered_groups.append(group)
        
        # 准备数据
        box_data = []
        labels = []
        
        for group in ordered_groups:
            # 获取当前组的所有site数据
            mask = plot_data[self.condition_col] == group
            group_data = plot_data.loc[mask, self.current_parameter].dropna()
            
            if len(group_data) > 0:
                box_data.append(group_data)
                labels.append(group)
        
        if not box_data:
            ax.text(0.5, 0.5, f"无数据可用于 {self.current_parameter}", 
                ha='center', va='center', transform=ax.transAxes)
            self.box_canvas.draw()
            return
        
        # 创建箱线图
        colors = []
        for label in labels:
            if label == "Baseline":
                colors.append('lightblue')
            elif label == "2nd tool":
                colors.append('lightgreen')
            else:
                colors.append('lightgray')
        
        # 绘制箱线图
        boxplot = ax.boxplot(box_data, patch_artist=True, labels=labels)
        
        # 设置颜色
        for i, patch in enumerate(boxplot['boxes']):
            if i < len(colors):
                patch.set_facecolor(colors[i])
        
        # 添加标题和标签
        ax.set_title(f'Box Plot - {self.current_parameter}')
        ax.set_ylabel(self.current_parameter)
        
        # 标记临时选择的点（用红色X）- 仅在标记模式下
        if mark_only and self.current_parameter in self.temp_selected_points and self.temp_selected_points[self.current_parameter]:
            excluded_data = []
            
            # 对每个组单独标记
            for group_idx, group in enumerate(labels):
                # 获取临时选择的点
                temp_selected = [
                    (wafer_id, site_id) for cond, wafer_id, site_id in self.temp_selected_points[self.current_parameter]
                    if cond == group
                ]
                
                if temp_selected:
                    original_data = self.transformed_data.copy()
                    for wafer_id, site_id in temp_selected:
                        wafer_mask = original_data[self.wafer_id_col] == wafer_id
                        site_mask = original_data[self.site_col] == site_id
                        group_mask = original_data[self.condition_col] == group
                        # 获取这个点的值
                        points = original_data[wafer_mask & site_mask & group_mask][self.current_parameter].dropna()
                        
                        if len(points) > 0:
                            # 添加到排除数据列表
                            for val in points:
                                excluded_data.append((group_idx + 1, val))
            
            # 在箱线图上标记这些点
            if excluded_data:
                x_positions, y_values = zip(*excluded_data)
                ax.scatter(x_positions, y_values, color='red', marker='x', s=100, alpha=0.7)
        
        # 添加一个k-shift值的注释
        if len(labels) >= 2:
            stats_dict, baseline_group, second_tool_group = self.calculate_statistics(
                self.current_parameter, 
                self.condition_col, 
                ordered_groups, 
                self.excluded_points
            )
            
            if second_tool_group in stats_dict and 'K-shift' in stats_dict[second_tool_group]:
                k_shift = stats_dict[second_tool_group]['K-shift']
                if not np.isnan(k_shift):
                    # 在图表右上角添加K-shift值
                    k_shift_text = f'K-shift: {k_shift:.3f}'
                    # 设置颜色
                    color = 'green' if abs(k_shift) < 1.5 else 'red'
                    ax.annotate(k_shift_text, xy=(0.95, 0.95), xycoords='axes fraction', 
                            ha='right', va='top', fontsize=10, color=color)
        
        # 刷新画布
        self.box_canvas.draw()

    def update_qq_plot(self, mark_only=False):
        """更新QQ图"""
        # 清除当前图表
        self.qq_fig.clear()
        ax = self.qq_fig.add_subplot(111)
        
        # 使用所有site数据，不做wafer平均
        plot_data = self.display_data.copy()
        
        # 确保Baseline和2nd tool始终是固定颜色
        color_map = {
            "Baseline": 'blue',
            "2nd tool": 'green'
        }
        marker_map = {
            "Baseline": 'o',
            "2nd tool": 's'
        }
        
        # 绘制的顺序 - 确保图例显示顺序一致
        ordered_groups = []
        for expected_group in ["Baseline", "2nd tool"]:
            if expected_group in self.condition_types:
                ordered_groups.append(expected_group)
        
        # 如果有其他不在预期内的组，也添加进来
        for group in self.condition_types:
            if group not in ordered_groups:
                ordered_groups.append(group)
        
        # 保存每个组的点数据，用于后续标记
        group_points = {}
        
        for group in ordered_groups:
            # 获取当前组的数据
            mask = plot_data[self.condition_col] == group
            group_data = plot_data.loc[mask, self.current_parameter].dropna()
            
            if len(group_data) == 0:
                continue
            
            # 保存原始数据点
            group_points[group] = {
                'wafer_ids': plot_data.loc[mask, self.wafer_id_col].values,
                'site_ids': plot_data.loc[mask, self.site_col].values,
                'values': group_data.values
            }
            
            # 排序数据
            sorted_data = np.sort(group_data)
            n = len(sorted_data)
            
            # JMP概率计算公式: (i-0.375)/(n+0.25)
            probabilities = np.array([(i + 1 - 0.375) / (n + 0.25) for i in range(n)])
            
            # 转换为正态分布的分位数
            norm_quantiles = stats.norm.ppf(probabilities)
            
            # 绘制 - 使用对应颜色和标记
            color = color_map.get(group, 'gray')  # 如果不是预期组，使用灰色
            marker = marker_map.get(group, '^')
            
            ax.plot(sorted_data, norm_quantiles, color=color, marker=marker,
                   linestyle='-', label=group, markersize=6)
        
        # 标记临时选择的点（红色X）- 仅在标记模式下
        if mark_only and self.current_parameter in self.temp_selected_points and self.temp_selected_points[self.current_parameter]:
            for group in ordered_groups:
                # 获取临时选择的点
                temp_selected = [
                    (wafer_id, site_id) for cond, wafer_id, site_id in self.temp_selected_points[self.current_parameter]
                    if cond == group
                ]
                
                if temp_selected and group in group_points:
                    # 获取原始数据中这些点的值和对应的分位数
                    original_data = self.transformed_data.copy()
                    
                    for wafer_id, site_id in temp_selected:
                        wafer_mask = original_data[self.wafer_id_col] == wafer_id
                        site_mask = original_data[self.site_col] == site_id
                        group_mask = original_data[self.condition_col] == group
                        # 获取这个点的值
                        points = original_data[wafer_mask & site_mask & group_mask][self.current_parameter].dropna()
                        
                        if len(points) > 0:
                            # 对每个点计算其对应的正态分位数
                            for value in points:
                                # 在对应组的数据中找到这个值应该在的位置
                                group_values = np.sort(group_points[group]['values'])
                                n = len(group_values)
                                
                                if n > 0:
                                    try:
                                        # 找到最接近的值的索引
                                        idx = min(range(len(group_values)), key=lambda i: abs(group_values[i] - value))
                                        # 计算对应的概率
                                        prob = (idx + 1 - 0.375) / (n + 0.25)
                                        # 计算正态分位数
                                        quantile = stats.norm.ppf(prob)
                                        
                                        # 在图上标记
                                        ax.scatter(value, quantile, color='red', marker='x', s=100, alpha=0.7)
                                    except Exception as e:
                                        print(f"标记QQ图点时出错: {e}")
    
        
        # 添加标题和标签
        ax.set_title(f'Normal Quantile Plot - {self.current_parameter}')
        ax.set_xlabel(self.current_parameter)
        ax.set_ylabel('Normal Quantile')
        
        # Y轴使用概率刻度
        prob_ticks = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99]
        quantile_ticks = stats.norm.ppf(prob_ticks)
        ax.set_yticks(quantile_ticks)
        ax.set_yticklabels([f'{p:.2f}' for p in prob_ticks])
        
        # 添加参考线
        ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
        
        # 添加图例
        ax.legend(loc='best')
        
        # 添加网格
        ax.grid(True, alpha=0.3)
        
        # 刷新画布
        self.qq_canvas.draw()

    # 更新的图表选择功能
    def enable_selection_mode(self, mode):
        """启用选择模式"""
        # 禁用其他按钮，避免同时激活多个选择模式
        self.rect_select_btn.setEnabled(False)
        self.lasso_select_btn.setEnabled(False)
        
        # 清除临时选择的点
        self.temp_selected_points = {}
        
        # 在当前活跃的选项卡上启用选择
        current_tab_index = self.findChild(QTabWidget).currentIndex()
        
        if current_tab_index == 0:  # Box Plot
            self.box_canvas.enable_selection(mode, self.on_box_selection)
        elif current_tab_index == 1:  # QQ Plot
            self.qq_canvas.enable_selection(mode, self.on_qq_selection)
        elif current_tab_index == 2:  # Wafer散点图
            # 对于Wafer散点图，我们不提供交互式选择
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)
            QMessageBox.information(self, "提示", "Wafer散点图不支持交互式选择")

    def confirm_selection(self):
        """确认删除当前选择的点"""
        if not self.temp_selected_points or self.current_parameter not in self.temp_selected_points:
            return
        
        # 保存操作前的状态，用于上一步功能
        if self.current_parameter in self.excluded_points:
            prev_excluded = self.excluded_points[self.current_parameter].copy()
        else:
            prev_excluded = []
        prev_display_data = self.display_data.copy()
        self.operation_history.append((self.current_parameter, prev_excluded, prev_display_data))
        self.undo_select_btn.setEnabled(True)
        
        # 更新排除点列表
        if self.current_parameter not in self.excluded_points:
            self.excluded_points[self.current_parameter] = []
        
        # 添加临时选择的点
        for point in self.temp_selected_points[self.current_parameter]:
            if point not in self.excluded_points[self.current_parameter]:
                self.excluded_points[self.current_parameter].append(point)
        
        # 更新显示数据 - 从display_data中移除这些点
        for condition, wafer_id, site_id in self.temp_selected_points[self.current_parameter]:
            wafer_mask = self.display_data[self.wafer_id_col] == wafer_id
            site_mask = self.display_data[self.site_col] == site_id
            condition_mask = self.display_data[self.condition_col] == condition
            self.display_data = self.display_data[~(wafer_mask & site_mask & condition_mask)]
        
        # 清除临时选择
        self.temp_selected_points = {}
        
        # 更新图表和统计
        self.update_plot()
        self.update_stats_view()
        
        # 启用选择按钮
        self.rect_select_btn.setEnabled(True)
        self.lasso_select_btn.setEnabled(True)
        
        # 禁用确认按钮
        self.confirm_select_btn.setEnabled(False)    

    def on_box_selection(self, indices, line):
        """箱形图选择回调 - 优化版本"""
        if not indices.size:
            return
            
        try:
            # 启用确认按钮
            self.confirm_select_btn.setEnabled(True)
            
            # 确保Baseline总是第一个，2nd tool总是第二个
            ordered_groups = []
            for expected_group in ["Baseline", "2nd tool"]:
                if expected_group in self.condition_types:
                    ordered_groups.append(expected_group)
            
            # 如果有其他不在预期内的组，也添加进来
            for group in self.condition_types:
                if group not in ordered_groups:
                    ordered_groups.append(group)
            
            # 获取当前图形的所有艺术对象
            all_objects = self.box_fig.axes[0].get_children()
            
            # 确定用户点击的x坐标 (对应的条件组)
            x_coords = line.get_xdata()[indices]
            y_coords = line.get_ydata()[indices]
            
            # 确定x坐标对应的组索引
            group_indices = []
            for x in x_coords:
                # 箱形图每个分组的x坐标是整数
                # 四舍五入到最近的整数，然后减1得到索引
                group_idx = round(x) - 1
                if 0 <= group_idx < len(ordered_groups):
                    group_indices.append(group_idx)
            
            # 如果找不到有效的组索引，尝试从线对象猜测
            if not group_indices:
                # 尝试获取线对象的x坐标的平均值
                x_mean = np.mean(line.get_xdata())
                group_idx = round(x_mean) - 1
                if 0 <= group_idx < len(ordered_groups):
                    group_indices = [group_idx]
            
            # 如果还找不到有效的组，报告错误并返回
            if not group_indices:
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                QMessageBox.warning(self, "警告", "无法确定选择的组，请尝试在箱形图主体上选择")
                return
            
            # 获取y坐标范围
            y_min = min(y_coords)
            y_max = max(y_coords)
            
            # 准备选择的点
            selected_points = []  # 存储格式为 (group, wafer_id, site_id)
            
            # 处理每个识别的组
            for group_idx in group_indices:
                group = ordered_groups[group_idx]
                
                # 获取该组在当前显示数据中的所有点
                mask = self.display_data[self.condition_col] == group
                group_data = self.display_data.loc[mask].copy()
                
                # 筛选y坐标范围内的点
                value_mask = (group_data[self.current_parameter] >= y_min) & (group_data[self.current_parameter] <= y_max)
                matched_data = group_data[value_mask]
                
                # 找出这些数据点对应的wafer ID和site ID
                for idx, row in matched_data.iterrows():
                    selected_points.append((group, row[self.wafer_id_col], row[self.site_col]))
            
            # 如果没有找到点，重新启用按钮并提示用户
            if not selected_points:
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                QMessageBox.warning(self, "警告", "所选区域内未找到数据点")
                return
            
            # 更新临时选择点列表
            if self.current_parameter not in self.temp_selected_points:
                self.temp_selected_points[self.current_parameter] = []
            
            # 添加新选择的点
            for point in selected_points:
                if point not in self.temp_selected_points[self.current_parameter]:
                    self.temp_selected_points[self.current_parameter].append(point)
            
            # 更新图表，仅标记选择的点
            self.update_plot(mark_only=True)
            
        except Exception as e:
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)
            QMessageBox.warning(self, "警告", f"处理选择时出错: {str(e)}\n{traceback.format_exc()}")

    def on_qq_selection(self, indices, line):
        """QQ图选择回调 - 优化版本"""
        if not indices.size:
            return
            
        try:
            # 启用确认按钮
            self.confirm_select_btn.setEnabled(True)
            
            # 确保有序的组
            ordered_groups = []
            for expected_group in ["Baseline", "2nd tool"]:
                if expected_group in self.condition_types:
                    ordered_groups.append(expected_group)
            
            for group in self.condition_types:
                if group not in ordered_groups:
                    ordered_groups.append(group)
            
            # 找出所选线条对应的组
            line_color = line.get_color()
            line_marker = line.get_marker()
            
            # 遍历所有线条，找出匹配的组
            matching_group = None
            for group in ordered_groups:
                # 根据上下文中的color_map和marker_map判断
                expected_color = 'blue' if group == 'Baseline' else 'green' if group == '2nd tool' else 'gray'
                expected_marker = 'o' if group == 'Baseline' else 's' if group == '2nd tool' else '^'
                
                if (line_color == expected_color and line_marker == expected_marker) or \
                (expected_color in line_color):  # 颜色可能是hex或RGB格式
                    matching_group = group
                    break
            
            # 如果无法通过颜色和标记确定组，使用散点图上下文和坐标判断
            if not matching_group:
                # 通过用户选择的x值范围在图上进行区域查询
                x_vals = line.get_xdata()[indices]
                x_min, x_max = min(x_vals), max(x_vals)
                y_vals = line.get_ydata()[indices]
                y_min, y_max = min(y_vals), max(y_vals)
                
                # 查找所有组的数据散点
                group_matches = {}
                for group in ordered_groups:
                    mask = self.display_data[self.condition_col] == group
                    group_data = self.display_data.loc[mask, self.current_parameter].dropna()
                    
                    if len(group_data) == 0:
                        continue
                    
                    # 计算与选择区域重叠的点的数量
                    in_range = ((group_data >= x_min) & (group_data <= x_max)).sum()
                    group_matches[group] = in_range
                
                # 选择重叠点最多的组
                if group_matches:
                    matching_group = max(group_matches, key=group_matches.get)
            
            if not matching_group:
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                QMessageBox.warning(self, "警告", "无法确定选择的组，请尝试选择更明确的区域")
                return
            
            # 获取所选点的x值范围（实际测量值）
            x_vals = line.get_xdata()[indices]
            x_min, x_max = min(x_vals), max(x_vals)
            
            # 找出对应的晶圆和site数据点
            selected_points = []  # 存储格式为 (group, wafer_id, site_id)
            mask = self.display_data[self.condition_col] == matching_group
            group_data = self.display_data[mask].copy()
            
            # 筛选x坐标（参数值）在范围内的点
            value_mask = (group_data[self.current_parameter] >= x_min) & (group_data[self.current_parameter] <= x_max)
            matched_data = group_data[value_mask]
            
            # 找出这些数据点对应的wafer ID和site ID
            for idx, row in matched_data.iterrows():
                selected_points.append((matching_group, row[self.wafer_id_col], row[self.site_col]))
            
            if not selected_points:
                # 重新启用选择按钮
                self.rect_select_btn.setEnabled(True)
                self.lasso_select_btn.setEnabled(True)
                QMessageBox.warning(self, "警告", "所选区域内未找到匹配的数据点")
                return
            
            # 更新临时选择点列表
            if self.current_parameter not in self.temp_selected_points:
                self.temp_selected_points[self.current_parameter] = []
            
            # 添加新选择的点
            for point in selected_points:
                if point not in self.temp_selected_points[self.current_parameter]:
                    self.temp_selected_points[self.current_parameter].append(point)
            
            # 更新图表，仅标记选择的点
            self.update_plot(mark_only=True)
            
        except Exception as e:
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)
            QMessageBox.warning(self, "警告", f"处理选择时出错: {str(e)}\n{traceback.format_exc()}")

    def clear_selection(self):
        """清除当前参数的选择"""
        if self.current_parameter in self.excluded_points:
            # 保存操作前的状态，用于上一步功能
            prev_excluded = self.excluded_points[self.current_parameter].copy()
            prev_display_data = self.display_data.copy()
            self.operation_history.append((self.current_parameter, prev_excluded, prev_display_data))
            self.undo_select_btn.setEnabled(True)
            
            # 删除当前参数的排除点
            del self.excluded_points[self.current_parameter]
            
            # 重置显示数据，使其与原始数据一致
            self.display_data = self.transformed_data.copy()
            
            # 清除临时选择
            if self.current_parameter in self.temp_selected_points:
                del self.temp_selected_points[self.current_parameter]
            self.confirm_select_btn.setEnabled(False)
            
            # 更新图表和统计
            self.update_plot()
            self.update_stats_view()
            
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)
        elif self.current_parameter in self.temp_selected_points:
            # 如果有临时选择但没有确认，清除临时选择
            del self.temp_selected_points[self.current_parameter]
            self.confirm_select_btn.setEnabled(False)
            
            # 更新图表，不显示临时标记
            self.update_plot()
            
            # 重新启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)  

    def clear_excluded_points(self):
        """清除所有排除点"""
        if self.excluded_points:
            # 保存操作前的状态
            self.operation_history = []  # 清空操作历史
            self.undo_select_btn.setEnabled(False)
            
            # 清空排除点和临时选择
            self.excluded_points = {}
            self.temp_selected_points = {}
            
            # 重置显示数据
            self.display_data = self.transformed_data.copy()
            
            # 更新图表和统计
            self.update_plot()
            self.update_stats_view()
            
            # 禁用确认按钮
            self.confirm_select_btn.setEnabled(False)
            
            # 启用选择按钮
            self.rect_select_btn.setEnabled(True)
            self.lasso_select_btn.setEnabled(True)

    def undo_selection(self):
        """撤销上一次选择操作"""
        if not self.operation_history:
            return
        
        # 获取上一次操作前的状态
        last_operation = self.operation_history.pop()
        parameter, exclude_points, display_data_state = last_operation
        
        # 恢复排除点列表
        if exclude_points:
            self.excluded_points[parameter] = exclude_points
        else:
            # 如果之前没有排除点，删除该键
            if parameter in self.excluded_points:
                del self.excluded_points[parameter]
        
        # 恢复显示数据状态
        self.display_data = display_data_state.copy()
        
        # 清除临时选择
        self.temp_selected_points = {}
        self.confirm_select_btn.setEnabled(False)
        
        # 更新图表和统计视图
        self.update_plot()
        self.update_stats_view()
        
        # 如果没有历史操作了，禁用上一步按钮
        if not self.operation_history:
            self.undo_select_btn.setEnabled(False)
        
        # 启用选择按钮
        self.rect_select_btn.setEnabled(True)
        self.lasso_select_btn.setEnabled(True)   

    # 导出增强版本的Excel文件
    def export_excel(self):
        """导出Excel，保留原始数据和统计信息"""
        if self.transformed_data is None:
            QMessageBox.warning(self, "警告", "没有可导出的数据")
            return
            
        file_name, _ = QFileDialog.getSaveFileName(
            self, "导出Excel", "Wafer_Measurement_Analysis.xlsx", "Excel Files (*.xlsx)"
        )
        
        if file_name:
            try:
                # 创建Excel写入器
                with pd.ExcelWriter(file_name, engine='openpyxl') as writer:
                    # 导出原始数据
                    self.transformed_data.to_excel(writer, sheet_name='Raw Data', index=False)
                    
                    # 导出统计结果
                    stats_rows = []
                    param_kshifts = {}
                    
                    for parameter in self.available_parameters:
                        stats_dict, baseline_group, second_tool_group = self.calculate_statistics(
                            parameter, 
                            self.condition_col, 
                            self.condition_types, 
                            self.excluded_points
                        )
                        
                        # 记录K-shift值
                        if second_tool_group in stats_dict and 'K-shift' in stats_dict[second_tool_group]:
                            k_shift = stats_dict[second_tool_group]['K-shift']
                            param_kshifts[parameter] = k_shift
                        
                        # 添加基线组统计信息
                        if baseline_group in stats_dict:
                            baseline_stats = stats_dict[baseline_group]
                            stats_rows.append({
                                'Parameter': parameter,
                                'Condition': baseline_group,
                                'Mean': baseline_stats.get('Mean', np.nan),
                                'Std Dev': baseline_stats.get('Std Dev', np.nan),
                                'Count': baseline_stats.get('Count', 0),
                                'K-shift': np.nan
                            })
                        
                        # 添加对照组统计信息
                        if second_tool_group in stats_dict:
                            second_tool_stats = stats_dict[second_tool_group]
                            stats_rows.append({
                                'Parameter': parameter,
                                'Condition': second_tool_group,
                                'Mean': second_tool_stats.get('Mean', np.nan),
                                'Std Dev': second_tool_stats.get('Std Dev', np.nan),
                                'Count': second_tool_stats.get('Count', 0),
                                'K-shift': second_tool_stats.get('K-shift', np.nan)
                            })
                    
                    # 创建统计数据表
                    stats_df = pd.DataFrame(stats_rows)
                    stats_df.to_excel(writer, sheet_name='Statistics', index=False)
                    
                    # 创建K-shift摘要
                    k_shift_summary = []
                    all_within_threshold = True
                    
                    for param, k_shift in param_kshifts.items():
                        within_threshold = np.isnan(k_shift) or abs(k_shift) < 1.5
                        if not within_threshold:
                            all_within_threshold = False
                        
                        k_shift_summary.append({
                            'Parameter': param,
                            'K-shift': k_shift,
                            'Within Threshold': 'Yes' if within_threshold else 'No'
                        })
                    
                    k_shift_df = pd.DataFrame(k_shift_summary)
                    k_shift_df.to_excel(writer, sheet_name='K-shift Summary', index=False)
                    
                    # 创建一个总结页
                    summary_data = {
                        'Item': ['Total Wafers', 'Total Parameters', 'All K-shifts within threshold'],
                        'Value': [
                            len(self.transformed_data[self.wafer_id_col].unique()), 
                            len(self.available_parameters),
                            'Yes' if all_within_threshold else 'No'
                        ]
                    }
                    summary_df = pd.DataFrame(summary_data)
                    summary_df.to_excel(writer, sheet_name='Summary', index=False)
                
                QMessageBox.information(self, "成功", f"数据已导出到: {file_name}")
            except Exception as e:
                QMessageBox.critical(self, "错误", f"导出Excel时出错: {str(e)}\n{traceback.format_exc()}")
    
    # 更新的PPT创建函数，支持16:9格式和更多图表
    def create_ppt(self):
        """创建PPT报告，使用当前显示数据（已排除异常值），16:9格式"""
        if self.transformed_data is None:
            QMessageBox.warning(self, "警告", "没有可导出的数据")
            return
            
        file_name, _ = QFileDialog.getSaveFileName(
            self, "创建PPT", "Wafer_Measurement_Analysis.pptx", "PowerPoint Files (*.pptx)"
        )
        
        if file_name:
            try:
                # 创建演示文稿
                prs = Presentation()
                
                # 设置幻灯片大小为16:9格式
                prs.slide_width = Inches(13.33)
                prs.slide_height = Inches(7.5)
                
                # 添加空白幻灯片
                blank_slide_layout = prs.slide_layouts[6]  # 空白布局
                slide = prs.slides.add_slide(blank_slide_layout)
                
                # 添加标题 - 位置调高
                title_shape = slide.shapes.add_textbox(Inches(0), Inches(0.1), Inches(13.33), Inches(0.5))
                title_frame = title_shape.text_frame
                title_para = title_frame.add_paragraph()
                title_para.text = "Wafer Measurement Analysis Report"
                title_para.alignment = PP_ALIGN.CENTER
                title_run = title_para.runs[0]
                title_run.font.size = Pt(20)
                title_run.font.bold = True
                
                # 检查所有K-shift是否都小于1.5
                all_within_threshold, k_shift_values = self.check_all_kshift_less_than_threshold()
                
                # 添加结论文本框
                conclusion_shape = slide.shapes.add_textbox(Inches(0.2), Inches(0.7), Inches(13), Inches(0.3))
                conclusion_frame = conclusion_shape.text_frame
                conclusion_para = conclusion_frame.add_paragraph()
                
                if all_within_threshold:
                    conclusion_para.text = "All the WAT items are <1.5 sigma, comparable with POR"
                    conclusion_run = conclusion_para.runs[0]
                    conclusion_run.font.color.rgb = RGBColor(0, 128, 0)  # 绿色
                else:
                    conclusion_para.text = "Some WAT items exceed 1.5 sigma threshold, attention needed"
                    conclusion_run = conclusion_para.runs[0]
                    conclusion_run.font.color.rgb = RGBColor(255, 0, 0)  # 红色
                
                conclusion_run.font.bold = True
                conclusion_run.font.size = Pt(14)
                
                # 定义布局区域
                # 16:9格式下的布局调整
                chart_area_top = Inches(1.2)
                chart_area_height = Inches(4.0)
                table_area_top = Inches(5.3)
                table_area_height = Inches(2.0)
                
                # 左侧区域：散点图和箱形图
                left_area_x = Inches(0.2)
                left_area_width = Inches(4.0)
                
                # 中间和右侧区域：QQ图表
                middle_area_x = Inches(4.4)
                middle_area_width = Inches(4.5)
                right_area_x = Inches(9.1)
                right_area_width = Inches(4.0)
                
                # 确保Baseline在前，2nd tool在后
                ordered_group_values = []
                for expected_group in ["Baseline", "2nd tool"]:
                    if expected_group in self.condition_types:
                        ordered_group_values.append(expected_group)
                
                # 添加其他可能的组
                for group in self.condition_types:
                    if group not in ordered_group_values:
                        ordered_group_values.append(group)
                
                # 获取每个参数的统计数据，用于表格
                all_stats = {}
                
                # 为每个参数创建Wafer ID散点图和箱图 (左侧)
                for i, parameter in enumerate(self.available_parameters):
                    if i >= 3:  # 限制显示的参数数量
                        break
                        
                    y_pos = chart_area_top + i * (chart_area_height / 3)
                    
                    # 创建Wafer ID散点图
                    scatter_fig = Figure(figsize=(4, 1.2), dpi=100)
                    self.update_wafer_scatter_plot(scatter_fig, parameter)
                    
                    # 转换为字节流
                    scatter_buf = io.BytesIO()
                    scatter_fig.savefig(scatter_buf, format='png', bbox_inches='tight')
                    plt.close(scatter_fig)
                    scatter_buf.seek(0)
                    
                    # 添加到PPT
                    slide.shapes.add_picture(
                        scatter_buf, 
                        left_area_x, 
                        y_pos, 
                        width=left_area_width
                    )
                    
                    # 计算统计数据
                    stats_dict, baseline_group, second_tool_group = self.calculate_statistics(
                        parameter, 
                        self.condition_col, 
                        ordered_group_values,
                        self.excluded_points
                    )
                    all_stats[parameter] = (stats_dict, baseline_group, second_tool_group)
                
                # 创建QQ图 (中间和右侧区域)
                qq_positions = []
                
                # 中间列
                for i in range(3):
                    qq_positions.append((middle_area_x, chart_area_top + i * (chart_area_height / 3)))
                
                # 右侧列
                for i in range(3):
                    qq_positions.append((right_area_x, chart_area_top + i * (chart_area_height / 3)))
                
                # 最多放置6个QQ图
                for i, parameter in enumerate(self.available_parameters[:6]):
                    if i < len(qq_positions):
                        x_pos, y_pos = qq_positions[i]
                        
                        # 创建QQ图
                        qq_fig = Figure(figsize=(4, 1.2), dpi=100)
                        ax = qq_fig.add_subplot(111)
                        
                        # 确保Baseline和2nd tool始终是固定颜色
                        color_map = {
                            "Baseline": 'blue',
                            "2nd tool": 'green'
                        }
                        marker_map = {
                            "Baseline": 'o',
                            "2nd tool": 's'
                        }
                        
                        for group in ordered_group_values:
                            # 使用当前的display_data（已排除异常值）
                            mask = self.display_data[self.condition_col] == group
                            group_data = self.display_data.loc[mask, parameter].dropna()
                            
                            if len(group_data) == 0:
                                continue
                            
                            # 排序数据
                            sorted_data = np.sort(group_data)
                            n = len(sorted_data)
                            
                            # JMP概率计算公式: (i-0.375)/(n+0.25)
                            probabilities = np.array([(i + 1 - 0.375) / (n + 0.25) for i in range(n)])
                            
                            # 转换为正态分布的分位数
                            norm_quantiles = stats.norm.ppf(probabilities)
                            
                            # 绘制 - 使用对应颜色和标记
                            color = color_map.get(group, 'gray')  # 如果不是预期组，使用灰色
                            marker = marker_map.get(group, '^')
                            
                            ax.plot(sorted_data, norm_quantiles, color=color, marker=marker,
                                linestyle='-', label=group, markersize=4)
                        
                        # 添加标题
                        ax.set_title(parameter, fontsize=10)
                        
                        # 添加轴标签
                        ax.set_xlabel(parameter, fontsize=8)
                        ax.set_ylabel('Normal Quantile', fontsize=8)
                        
                        # Y轴使用概率刻度
                        prob_ticks = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99]
                        quantile_ticks = stats.norm.ppf(prob_ticks)
                        ax.set_yticks(quantile_ticks)
                        ax.set_yticklabels([f'{p:.2f}' for p in prob_ticks], fontsize=7)
                        ax.tick_params(axis='x', labelsize=7)
                        
                        # 添加参考线
                        ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
                        
                        # 添加图例
                        ax.legend(loc='best', fontsize=7)
                        
                        # 添加网格
                        ax.grid(True, alpha=0.3)
                        
                        qq_fig.tight_layout()
                        
                        # 转换为字节流
                        qq_buf = io.BytesIO()
                        qq_fig.savefig(qq_buf, format='png', bbox_inches='tight')
                        plt.close(qq_fig)
                        qq_buf.seek(0)
                        
                        # 添加到PPT
                        slide.shapes.add_picture(
                            qq_buf, 
                            x_pos, 
                            y_pos, 
                            width=middle_area_width if i < 3 else right_area_width
                        )
                
                # 创建底部的统计表格
                table_rows = len(self.available_parameters) + 2  # 参数数量 + 标题两行
                table_cols = 5  # Condition, BSL Mean, BSL Std Dev, 2nd Tool Mean, K-shift
                
                table = slide.shapes.add_table(
                    table_rows, 
                    table_cols,
                    Inches(0.5), 
                    table_area_top,
                    Inches(12.33), 
                    table_area_height
                ).table
                
                # 设置列宽
                table.columns[0].width = Inches(2.5)
                for i in range(1, 5):
                    table.columns[i].width = Inches(2.46)
                
                # 获取第一个参数的统计信息，以获取基准组和对照组
                if self.available_parameters and self.available_parameters[0] in all_stats:
                    _, baseline_group, second_tool_group = all_stats[self.available_parameters[0]]
                else:
                    baseline_group = ordered_group_values[0] if ordered_group_values else "Baseline"
                    second_tool_group = ordered_group_values[1] if len(ordered_group_values) > 1 else "2nd tool"
                
                # 添加表头
                header_cells = [
                    "Parameter", baseline_group, "", second_tool_group, ""
                ]
                for i, text in enumerate(header_cells):
                    cell = table.cell(0, i)
                    cell.text = text if text is not None else ""
                    # 设置粗体和字体大小
                    para = cell.text_frame.paragraphs[0]
                    para.alignment = PP_ALIGN.CENTER
                    if not para.runs:
                        run = para.add_run()
                        run.text = text if text is not None else ""
                    else:
                        run = para.runs[0]
                    run.font.bold = True
                    run.font.size = Pt(11)
                
                # 第二行表头
                subheader_cells = [
                    "Statistics", "Mean", "Std Dev", "Mean", "K-shift"
                ]
                for i, text in enumerate(subheader_cells):
                    cell = table.cell(1, i)
                    cell.text = text
                    # 设置粗体和字体大小
                    para = cell.text_frame.paragraphs[0]
                    para.alignment = PP_ALIGN.CENTER
                    if not para.runs:
                        run = para.add_run()
                        run.text = text
                    else:
                        run = para.runs[0]
                    run.font.bold = True
                    run.font.size = Pt(11)
                
                # 添加数据行
                for i, parameter in enumerate(self.available_parameters):
                    if i + 2 >= table_rows:  # 避免超出表格行数
                        break
                        
                    if parameter in all_stats:
                        stats_dict, baseline_group, second_tool_group = all_stats[parameter]
                        
                        # 准备数据
                        baseline_stats = stats_dict.get(baseline_group, {})
                        second_tool_stats = stats_dict.get(second_tool_group, {}) if second_tool_group else {}
                        
                        # 为小值启用科学记号
                        def format_value(value, param_name):
                            if value is None or np.isnan(value):
                                return 'N/A'
                            
                            # 判断是否为非常小的值 (例如LK类似的量级)
                            if 'LK' in param_name and abs(value) < 0.001:
                                return f"{value:.4e}"  # 使用科学记号
                            elif abs(value) < 0.0001:  # 其他很小的值也使用科学记号
                                return f"{value:.4e}"
                            else:
                                return f"{value:.4f}"  # 常规数值使用固定小数点
                        
                        row_data = [
                            parameter,
                            format_value(baseline_stats.get('Mean', np.nan), parameter) if 'Mean' in baseline_stats else 'N/A',
                            format_value(baseline_stats.get('Std Dev', np.nan), parameter) if 'Std Dev' in baseline_stats else 'N/A',
                            format_value(second_tool_stats.get('Mean', np.nan), parameter) if 'Mean' in second_tool_stats else 'N/A',
                            format_value(second_tool_stats.get('K-shift', np.nan), parameter) if 'K-shift' in second_tool_stats else 'N/A'
                        ]
                        
                        # 填充表格
                        for j, text in enumerate(row_data):
                            cell = table.cell(i + 2, j)
                            cell.text = text
                            para = cell.text_frame.paragraphs[0]
                            para.alignment = PP_ALIGN.CENTER
                            if not para.runs:
                                run = para.add_run()
                                run.text = text
                            else:
                                run = para.runs[0]
                            run.font.size = Pt(10)
                            
                            # 如果是K-shift且绝对值大于1.5，使用红色
                            if j == 4 and text != 'N/A':
                                try:
                                    k_shift_value = float(text)
                                    if abs(k_shift_value) >= 1.5:
                                        run.font.color.rgb = RGBColor(255, 0, 0)  # 红色
                                except:
                                    pass
                
                # 保存演示文稿
                prs.save(file_name)
                QMessageBox.information(self, "成功", f"已创建PPT文件: {file_name}")
                
            except Exception as e:
                QMessageBox.critical(self, "错误", f"创建PPT时出错: {str(e)}\n{traceback.format_exc()}")

    def show_about(self):
        """显示关于对话框"""
        about_text = """
        <h3>晶圆测量分析工具</h3>
        <p>版本: 1.0</p>
        <p>这是一个用于分析晶圆测量数据的工具，支持：</p>
        <ul>
            <li>数据加载和处理</li>
            <li>交互式箱形图和QQ图</li>
            <li>异常值识别和标记</li>
            <li>统计分析</li>
            <li>导出Excel和PPT报告</li>
        </ul>
        <p>使用说明:</p>
        <ol>
            <li>加载查询数据和条件数据（或使用模拟数据）</li>
            <li>处理数据后，在下拉菜单选择要分析的参数</li>
            <li>在箱形图或QQ图上，使用矩形选择或套索选择工具标记异常值</li>
            <li>点击"确认删除"按钮应用更改，从图表中移除选中的点</li>
            <li>可以导出Excel（保留原始数据）或创建PPT报告（排除标记的点）</li>
            <li>使用"上一步"按钮可以撤销上一次操作</li>
        </ol>
        <p>&copy; 2023 晶圆测量分析工具</p>
        """
        QMessageBox.about(self, "关于", about_text)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WaferAnalysisApp()
    window.show()
    sys.exit(app.exec())

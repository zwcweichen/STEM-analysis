import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
import matplotlib.gridspec as gridspec
from matplotlib.patches import Patch
import os
import io
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE
from pptx.enum.text import PP_ALIGN

def create_jmp_quantile_plot(data, parameter, group_col, group_values, fig_size=(3, 3), dpi=100):
    """
    创建JMP风格的Quantile Plot（凹口向下）并返回图像字节流
    """
    fig, ax = plt.subplots(figsize=fig_size, dpi=dpi)
    
    colors = ['blue', 'green']  # BSL蓝色，2nd tool绿色
    markers = ['o', 's']
    
    for i, group in enumerate(group_values):
        # 获取当前组的数据
        group_data = data[data[group_col] == group][parameter].dropna()
        
        if len(group_data) == 0:
            continue
        
        # 排序数据
        sorted_data = np.sort(group_data)
        n = len(sorted_data)
        
        # JMP概率计算公式: (i-0.375)/(n+0.25)
        probabilities = np.array([(i + 1 - 0.375) / (n + 0.25) for i in range(n)])
        
        # 转换为正态分布的分位数
        norm_quantiles = stats.norm.ppf(probabilities)
        
        # 绘制
        ax.plot(sorted_data, norm_quantiles, color=colors[i], marker=markers[i],
                linestyle='-', label=group, markersize=4)
    
    # 添加标题
    ax.set_title(parameter, fontsize=10)
    
    # 添加轴标签
    ax.set_xlabel(parameter, fontsize=8)
    ax.set_ylabel('Normal Quantile', fontsize=8)
    
    # Y轴使用概率刻度
    prob_ticks = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99]
    quantile_ticks = stats.norm.ppf(prob_ticks)
    ax.set_yticks(quantile_ticks)
    ax.set_yticklabels([f'{p:.2f}' for p in prob_ticks], fontsize=7)
    ax.tick_params(axis='x', labelsize=7)
    
    # 添加参考线
    ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
    
    # 添加图例
    ax.legend(loc='best', fontsize=7)
    
    # 添加网格
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # 转换为字节流
    buf = io.BytesIO()
    fig.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    
    return buf

def create_box_plot(data, parameter, group_col, group_values, fig_size=(3, 3), dpi=100):
    """
    创建Box Plot比较不同工具类别并返回图像字节流
    """
    fig, ax = plt.subplots(figsize=fig_size, dpi=dpi)
    
    # 准备数据
    box_data = []
    valid_labels = []
    
    for group in group_values:
        group_data = data[data[group_col] == group][parameter].dropna()
        if len(group_data) > 0:
            box_data.append(group_data)
            valid_labels.append(group)
    
    if not box_data:
        ax.text(0.5, 0.5, f"无数据可用于 {parameter}", ha='center', va='center', transform=ax.transAxes)
        plt.close(fig)
        return None
    
    # 创建箱线图
    boxplot = ax.boxplot(box_data, patch_artist=True, tick_labels=valid_labels)
    
    # 设置颜色
    colors = ['lightblue', 'lightgreen']
    for i, patch in enumerate(boxplot['boxes']):
        if i < len(colors):
            patch.set_facecolor(colors[i])
    
    # 添加标题
    ax.set_title(f'Box Plot - {parameter}', fontsize=10)
    ax.set_ylabel(parameter, fontsize=8)
    ax.tick_params(axis='both', labelsize=7)
    
    plt.tight_layout()
    
    # 转换为字节流
    buf = io.BytesIO()
    fig.savefig(buf, format='png', bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    
    return buf

def calculate_statistics(data, parameter, group_col, group_values):
    """
    计算统计信息：Mean, Std Dev, K-shift
    """
    stats_dict = {}
    
    for group in group_values:
        group_data = data[data[group_col] == group][parameter].dropna()
        
        if len(group_data) > 0:
            stats_dict[group] = {
                'Mean': np.mean(group_data),
                'Std Dev': np.std(group_data, ddof=1)
            }
        else:
            stats_dict[group] = {
                'Mean': np.nan,
                'Std Dev': np.nan
            }
    
    # 计算K-shift
    if len(group_values) >= 2 and not np.isnan(stats_dict[group_values[0]]['Std Dev']) and stats_dict[group_values[0]]['Std Dev'] != 0:
        stats_dict[group_values[1]]['K-shift'] = (
            stats_dict[group_values[1]]['Mean'] - stats_dict[group_values[0]]['Mean']
        ) / stats_dict[group_values[0]]['Std Dev']
    else:
        if group_values[1] in stats_dict:
            stats_dict[group_values[1]]['K-shift'] = np.nan
    
    return stats_dict

def create_single_page_ppt(data, parameters, group_col, group_values, output_file='Wafer_Analysis_Report.pptx'):
    """
    创建单页PPT报告，包含所有参数的分析
    """
    # 创建演示文稿
    prs = Presentation()
    
    # 设置幻灯片大小为标准尺寸(4:3)
    prs.slide_width = Inches(10)
    prs.slide_height = Inches(7.5)
    
    # 添加空白幻灯片
    blank_slide_layout = prs.slide_layouts[6]  # 空白布局
    slide = prs.slides.add_slide(blank_slide_layout)
    
    # 添加标题
    title_shape = slide.shapes.add_textbox(Inches(0), Inches(0.2), Inches(10), Inches(0.5))
    title_frame = title_shape.text_frame
    title_para = title_frame.add_paragraph()
    title_para.text = "Wafer Measurement Analysis Report"
    title_para.alignment = PP_ALIGN.CENTER
    title_run = title_para.runs[0]
    title_run.font.size = Pt(20)
    title_run.font.bold = True
    
    # 左侧放置Box Plot
    left_panel_x = Inches(0.2)
    left_panel_y = Inches(0.8)
    left_panel_width = Inches(3.5)
    left_panel_height = Inches(5.0)
    
    # 右侧放置Quantile Plot (2x3网格)
    right_panel_x = Inches(3.8)
    right_panel_y = Inches(0.8)
    right_panel_width = Inches(6.0)
    right_panel_height = Inches(5.0)
    
    # 计算单个Box Plot的尺寸
    box_plot_height = left_panel_height / len(parameters)
    
    # 计算单个Quantile Plot的尺寸
    quantile_plot_width = right_panel_width / 2
    quantile_plot_height = right_panel_height / 3
    
    # 获取每个参数的统计数据，用于最后的表格
    all_stats = {}
    
    # 创建左侧Box Plot
    for i, parameter in enumerate(parameters):
        # 计算Box Plot位置
        y_pos = left_panel_y + i * box_plot_height
        
        # 创建Box Plot
        box_plot_img = create_box_plot(
            data, 
            parameter, 
            group_col, 
            group_values, 
            fig_size=(4, 1.7), 
            dpi=100
        )
        
        if box_plot_img:
            slide.shapes.add_picture(
                box_plot_img, 
                left_panel_x, 
                y_pos, 
                width=left_panel_width
            )
        
        # 计算统计数据
        stats_dict = calculate_statistics(data, parameter, group_col, group_values)
        all_stats[parameter] = stats_dict
    
    # 创建右侧Quantile Plot (2x3网格)
    grid_positions = [
        # Col 1
        (right_panel_x, right_panel_y),                             # Row 1, Col 1
        (right_panel_x, right_panel_y + quantile_plot_height),      # Row 2, Col 1
        (right_panel_x, right_panel_y + 2 * quantile_plot_height),  # Row 3, Col 1
        # Col 2
        (right_panel_x + quantile_plot_width, right_panel_y),                        # Row 1, Col 2
        (right_panel_x + quantile_plot_width, right_panel_y + quantile_plot_height), # Row 2, Col 2
        (right_panel_x + quantile_plot_width, right_panel_y + 2 * quantile_plot_height) # Row 3, Col 2
    ]
    
    # 最多放置6个Quantile Plot
    for i, parameter in enumerate(parameters[:6]):
        # 计算Quantile Plot位置
        if i < len(grid_positions):
            x_pos, y_pos = grid_positions[i]
            
            # 创建Quantile Plot
            quantile_plot_img = create_jmp_quantile_plot(
                data, 
                parameter, 
                group_col, 
                group_values, 
                fig_size=(2.9, 1.7), 
                dpi=100
            )
            
            slide.shapes.add_picture(
                quantile_plot_img, 
                x_pos, 
                y_pos, 
                width=quantile_plot_width
            )
    
    # 创建底部的统计表格
    table_rows = len(parameters) + 2  # 参数数量 + 标题两行
    table_cols = 5  # Condition, BSL Mean, BSL Std Dev, 2nd Tool Mean, K-shift
    
    table = slide.shapes.add_table(
        table_rows, 
        table_cols,
        Inches(0.5), 
        Inches(5.9),
        Inches(9), 
        Inches(1.5)
    ).table
    
    # 设置列宽
    table.columns[0].width = Inches(2.0)
    for i in range(1, 5):
        table.columns[i].width = Inches(1.75)
    
    # 添加表头 - 修复版本
    header_cells = [
        "Condition", "BSL", "", "2nd tool", ""
    ]
    for i, text in enumerate(header_cells):
        cell = table.cell(0, i)
        cell.text = text
        # 安全地设置粗体和字体大小
        para = cell.text_frame.paragraphs[0]
        para.alignment = PP_ALIGN.CENTER
        if not para.runs:
            run = para.add_run()
            run.text = text
        else:
            run = para.runs[0]
        run.font.bold = True
        run.font.size = Pt(11)
    
    # 第二行表头
    subheader_cells = [
        "Statistics", "Mean", "Std Dev", "Mean", "K-shift"
    ]
    for i, text in enumerate(subheader_cells):
        cell = table.cell(1, i)
        cell.text = text
        # 安全地设置粗体和字体大小
        para = cell.text_frame.paragraphs[0]
        para.alignment = PP_ALIGN.CENTER
        if not para.runs:
            run = para.add_run()
            run.text = text
        else:
            run = para.runs[0]
        run.font.bold = True
        run.font.size = Pt(11)
    
    # 添加数据行
    for i, parameter in enumerate(parameters):
        stats_dict = all_stats.get(parameter, {})
        
        if not stats_dict:
            continue
            
        bsl_group = list(stats_dict.keys())[0]
        second_group = list(stats_dict.keys())[1] if len(stats_dict) > 1 else None
        
        # 准备数据
        bsl_stats = stats_dict.get(bsl_group, {})
        second_stats = stats_dict.get(second_group, {}) if second_group else {}
        
        row_data = [
            parameter,
            f"{bsl_stats.get('Mean', np.nan):.4f}" if 'Mean' in bsl_stats and not np.isnan(bsl_stats['Mean']) else 'N/A',
            f"{bsl_stats.get('Std Dev', np.nan):.4f}" if 'Std Dev' in bsl_stats and not np.isnan(bsl_stats['Std Dev']) else 'N/A',
            f"{second_stats.get('Mean', np.nan):.4f}" if 'Mean' in second_stats and not np.isnan(second_stats['Mean']) else 'N/A',
            f"{second_stats.get('K-shift', np.nan):.4f}" if 'K-shift' in second_stats and not np.isnan(second_stats['K-shift']) else 'N/A'
        ]
        
        # 填充表格
        for j, text in enumerate(row_data):
            cell = table.cell(i + 2, j)
            cell.text = text
            para = cell.text_frame.paragraphs[0]
            para.alignment = PP_ALIGN.CENTER
            if not para.runs:
                run = para.add_run()
                run.text = text
            else:
                run = para.runs[0]
            run.font.size = Pt(10)
    
    # 保存演示文稿
    prs.save(output_file)
    print(f"已创建PPT文件: {output_file}")
    
    return output_file

def create_sample_data(n_wafers=30):
    """
    创建模拟数据集
    """
    # 创建wafer IDs
    wafer_ids = [f'Wafer_{i:03d}' for i in range(1, n_wafers+1)]
    
    # 工具类别
    tools = ['Tool_A', 'Tool_B']
    
    # 创建condition_list数据
    condition_data = pd.DataFrame({
        'Wafer ID': wafer_ids,
        'BSL': np.random.choice(tools, size=n_wafers),
        '2nd tool': np.random.choice(tools, size=n_wafers)
    })
    
    # 创建量测数据
    param_names = ['Con_M3LA', 'Con_M3LB', 'Rc_V2v', 'LK_M3LA', 'LK_M3LB']
    
    rows = []
    for wafer_id in wafer_ids:
        for param in param_names:
            # 为每个wafer和每个参数创建多个site测量
            n_sites = np.random.randint(1, 5)
            for site in range(1, n_sites+1):
                # 随机生成0-9之间的值
                value = np.random.uniform(0, 9)
                rows.append({
                    'Wafer ID': wafer_id,
                    'Parameter Name': param,
                    'Site': f'Site_{site}',
                    'Site Value': value
                })
    
    query_data = pd.DataFrame(rows)
    
    return condition_data, query_data

def transform_data(query_data, condition_data):
    """
    将查询数据和条件数据转换为所需的格式
    """
    # 假设列名如下，需根据实际情况调整
    wafer_id_col = 'Wafer ID'
    parameter_col = 'Parameter Name'
    value_col = 'Site Value'
    bsl_col = 'BSL'
    second_tool_col = '2nd tool'
    
    # 合并数据
    merged_data = pd.merge(query_data, condition_data, on=wafer_id_col, how='left')
    
    # 创建数据透视表
    try:
        # 先按Wafer ID和Parameter Name取平均，再创建透视表
        grouped_data = merged_data.groupby([wafer_id_col, parameter_col, bsl_col, second_tool_col])[value_col].mean().reset_index()
        
        pivot_data = grouped_data.pivot_table(
            index=[wafer_id_col, bsl_col, second_tool_col],
            columns=parameter_col,
            values=value_col
        ).reset_index()
        
        return pivot_data
    
    except Exception as e:
        print(f"创建数据透视表时出错: {e}")
        
        # 备用方法
        print("使用备用方法...")
        
        # 获取唯一的参数
        unique_params = merged_data[parameter_col].unique()
        
        # 创建新的数据框
        transformed_data = merged_data[[wafer_id_col, bsl_col, second_tool_col]].drop_duplicates()
        
        # 为每个参数创建列
        for param in unique_params:
            param_data = merged_data[merged_data[parameter_col] == param]
            param_data_grouped = param_data.groupby(wafer_id_col)[value_col].mean().reset_index()
            param_data_grouped = param_data_grouped.rename(columns={value_col: param})
            
            # 合并到转换后的数据
            transformed_data = pd.merge(transformed_data, param_data_grouped, on=wafer_id_col, how='left')
        
        return transformed_data

def read_data(query_file, condition_file):
    """
    读取查询数据和条件数据
    """
    try:
        query_data = pd.read_excel(query_file)
        condition_data = pd.read_excel(condition_file)
        
        print(f"成功读取 {query_file} 和 {condition_file}")
        
        return query_data, condition_data
    except Exception as e:
        print(f"读取文件时出错: {e}")
        return None, None

def main():
    """
    主函数：执行整个数据处理和分析流程
    """
    # 检查是否能读取实际数据
    try:
        query_data, condition_data = read_data('IEDA2_query.xlsx', 'condition_list.xlsx')
        if query_data is None or condition_data is None:
            raise Exception("无法读取实际数据文件")
        
        # 转换数据
        transformed_data = transform_data(query_data, condition_data)
        
    except Exception as e:
        print(f"使用实际数据时出错: {e}")
        print("将创建模拟数据继续演示...")
        
        # 创建模拟数据
        condition_data, query_data = create_sample_data(30)
        
        # 转换模拟数据
        transformed_data = transform_data(query_data, condition_data)
    
    # 参数列表
    parameters = ['Con_M3LA', 'Con_M3LB', 'Rc_V2v', 'LK_M3LA', 'LK_M3LB']
    
    # 工具类别分组列名和值
    group_col = 'BSL'  # 使用BSL列作为分组
    group_values = ['Tool_A', 'Tool_B']  # 假设工具值
    
    # 创建单页PPT
    output_file = 'Wafer_Measurement_Analysis.pptx'
    create_single_page_ppt(transformed_data, parameters, group_col, group_values, output_file)
    
    print("\n分析总结:")
    print("1. JMP风格Quantile Plot凹口向下是由于使用(i-0.375)/(n+0.25)概率公式")
    print("2. Python标准库默认使用i/(n+1)公式，产生凹口向上的曲线")
    print("3. 通过修改概率计算方法，成功模拟JMP风格的Quantile Plot")
    print(f"4. 分析结果已保存至PowerPoint文件: {output_file}")

if __name__ == "__main__":
    main()

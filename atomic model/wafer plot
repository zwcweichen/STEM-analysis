import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from matplotlib.colors import LinearSegmentedColormap, Normalize
from scipy.interpolate import griddata, Rbf
from scipy.ndimage import gaussian_filter
import matplotlib.patches as patches

# 创建更精确的自定义colormap（更接近您系统的颜色）
colors = ['#2E0854', '#1B4F9C', '#0080FF', '#00BFFF', '#40E0D0', '#7FFFD4', 
          '#ADFF2F', '#FFFF00', '#FFD700', '#FFA500', '#FF6347', '#FF0000', '#8B0000']
n_bins = 512  # 增加颜色分辨率
cmap_custom = LinearSegmentedColormap.from_list('wafer_enhanced', colors, N=n_bins)

def load_wafer_data(csv_file_path):
    """从CSV文件加载wafer数据"""
    try:
        df = pd.read_csv(csv_file_path)
        
        required_columns = ['Location x', 'Location y', 'CD']
        missing_columns = [col for col in required_columns if col not in df.columns]
        
        if missing_columns:
            print(f"警告：缺少以下列: {missing_columns}")
            print(f"可用的列: {list(df.columns)}")
            return None, None, None
        
        x = df['Location x'].values
        y = df['Location y'].values
        z = df['CD'].values
        
        # 移除NaN值
        valid_mask = ~(np.isnan(x) | np.isnan(y) | np.isnan(z))
        x = x[valid_mask]
        y = y[valid_mask]
        z = z[valid_mask]
        
        print(f"成功加载数据：{len(x)} 个有效数据点")
        print(f"X范围: {x.min():.2f} 到 {x.max():.2f}")
        print(f"Y范围: {y.min():.2f} 到 {y.max():.2f}")
        print(f"CD范围: {z.min():.2f} 到 {z.max():.2f}")
        
        return x, y, z
        
    except Exception as e:
        print(f"读取CSV文件时出错: {e}")
        return None, None, None

def advanced_interpolation(x, y, z, xi, yi, method='multi'):
    """
    高级插值方法，结合多种技术获得更好的效果
    """
    if method == 'multi':
        # 方法1: RBF插值（径向基函数）
        try:
            rbf = Rbf(x, y, z, function='multiquadric', smooth=0.1)
            zi_rbf = rbf(xi, yi)
        except:
            zi_rbf = griddata((x, y), z, (xi, yi), method='cubic')
        
        # 方法2: 改进的griddata
        try:
            zi_cubic = griddata((x, y), z, (xi, yi), method='cubic')
            zi_linear = griddata((x, y), z, (xi, yi), method='linear')
            # 组合cubic和linear结果
            mask_valid = ~np.isnan(zi_cubic)
            zi_combined = np.where(mask_valid, zi_cubic, zi_linear)
        except:
            zi_combined = griddata((x, y), z, (xi, yi), method='linear')
        
        # 加权平均两种方法
        weight_rbf = 0.6
        weight_grid = 0.4
        
        # 处理NaN值
        rbf_valid = ~np.isnan(zi_rbf)
        grid_valid = ~np.isnan(zi_combined)
        
        zi_final = np.full_like(xi, np.nan)
        both_valid = rbf_valid & grid_valid
        zi_final[both_valid] = (weight_rbf * zi_rbf[both_valid] + 
                               weight_grid * zi_combined[both_valid])
        
        # 只有一个有效的情况
        only_rbf = rbf_valid & ~grid_valid
        only_grid = ~rbf_valid & grid_valid
        zi_final[only_rbf] = zi_rbf[only_rbf]
        zi_final[only_grid] = zi_combined[only_grid]
        
        return zi_final
    
    elif method == 'rbf':
        rbf = Rbf(x, y, z, function='multiquadric', smooth=0.1)
        return rbf(xi, yi)
    
    else:
        return griddata((x, y), z, (xi, yi), method=method)

def create_enhanced_wafer_mask(xi, yi, x_data, y_data, buffer_ratio=0.05):
    """创建增强的wafer遮罩，更准确地反映数据分布"""
    # 计算数据的实际边界
    x_range = x_data.max() - x_data.min()
    y_range = y_data.max() - y_data.min()
    
    # 计算中心和半径
    center_x = (x_data.max() + x_data.min()) / 2
    center_y = (y_data.max() + y_data.min()) / 2
    
    # 使用实际数据点来确定更准确的wafer边界
    distances = np.sqrt((x_data - center_x)**2 + (y_data - center_y)**2)
    radius = np.percentile(distances, 95)  # 使用95%分位数作为半径
    
    # 创建平滑的圆形遮罩
    dist_from_center = np.sqrt((xi - center_x)**2 + (yi - center_y)**2)
    
    # 软边界遮罩（渐变边缘）
    edge_width = radius * 0.05  # 边缘宽度为半径的5%
    mask = np.ones_like(xi)
    
    # 内部区域
    inner_mask = dist_from_center <= radius - edge_width
    mask[inner_mask] = 1.0
    
    # 边缘区域（渐变）
    edge_mask = (dist_from_center > radius - edge_width) & (dist_from_center <= radius + edge_width)
    fade_factor = 1.0 - (dist_from_center[edge_mask] - (radius - edge_width)) / (2 * edge_width)
    mask[edge_mask] = fade_factor
    
    # 外部区域
    outer_mask = dist_from_center > radius + edge_width
    mask[outer_mask] = 0.0
    
    return mask, center_x, center_y, radius

def plot_enhanced_continuous_wafer_map(x, y, z, title="Enhanced Continuous Wafer Map", figsize=(12, 10)):
    """绘制增强版连续性wafer map"""
    fig, ax = plt.subplots(1, 1, figsize=figsize)
    
    # 使用更高的分辨率
    grid_density = 400  # 增加分辨率
    xi = np.linspace(x.min() * 1.1, x.max() * 1.1, grid_density)
    yi = np.linspace(y.min() * 1.1, y.max() * 1.1, grid_density)
    Xi, Yi = np.meshgrid(xi, yi)
    
    # 使用改进的插值方法
    print("正在进行高质量插值...")
    Zi = advanced_interpolation(x, y, z, Xi, Yi, method='multi')
    
    # 应用高斯平滑
    Zi_smooth = gaussian_filter(Zi, sigma=1.0)
    
    # 创建增强的wafer遮罩
    mask, center_x, center_y, radius = create_enhanced_wafer_mask(Xi, Yi, x, y)
    
    # 应用遮罩
    Zi_masked = np.where(mask > 0.1, Zi_smooth, np.nan)
    
    # 创建更精细的等高线级别
    z_min, z_max = np.nanmin(z), np.nanmax(z)
    levels = np.linspace(z_min, z_max, 100)
    
    # 绘制填充等高线
    contour = ax.contourf(Xi, Yi, Zi_masked, levels=levels, cmap=cmap_custom, 
                         extend='both', alpha=0.9)
    
    # 添加更细致的等高线
    contour_lines = ax.contour(Xi, Yi, Zi_masked, levels=30, colors='black', 
                              alpha=0.15, linewidths=0.3)
    
    # 绘制原始数据点，使用更好的样式
    scatter = ax.scatter(x, y, c=z, s=25, cmap=cmap_custom, 
                        edgecolors='white', linewidth=0.8, alpha=0.95, zorder=5)
    
    # 添加wafer边界圆
    circle = plt.Circle((center_x, center_y), radius, fill=False, 
                       color='black', linewidth=2.5, alpha=0.8)
    ax.add_patch(circle)
    
    # 美化颜色条
    cbar = plt.colorbar(contour, ax=ax, shrink=0.8, pad=0.02)
    cbar.set_label('CD Value (nm)', fontsize=12, fontweight='bold')
    cbar.ax.tick_params(labelsize=10)
    
    # 设置坐标轴
    margin = max((x.max() - x.min()), (y.max() - y.min())) * 0.05
    ax.set_xlim(x.min() - margin, x.max() + margin)
    ax.set_ylim(y.min() - margin, y.max() + margin)
    ax.set_aspect('equal')
    
    # 美化标题和标签
    ax.set_title(title, fontsize=16, fontweight='bold', pad=20)
    ax.set_xlabel('Location X (mm)', fontsize=12, fontweight='bold')
    ax.set_ylabel('Location Y (mm)', fontsize=12, fontweight='bold')
    
    # 添加网格
    ax.grid(True, alpha=0.2, linestyle='--')
    ax.tick_params(labelsize=10)
    
    # 添加统计信息框
    stats_text = (f'Data Points: {len(x)}\n'
                 f'Mean CD: {np.mean(z):.2f} nm\n'
                 f'Std Dev: {np.std(z):.2f} nm\n'
                 f'Range: {z.min():.2f} - {z.max():.2f} nm\n'
                 f'3σ Range: {np.mean(z) - 3*np.std(z):.2f} - {np.mean(z) + 3*np.std(z):.2f} nm')
    
    ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, fontsize=9,
            verticalalignment='top', bbox=dict(boxstyle='round,pad=0.5', 
            facecolor='white', alpha=0.8, edgecolor='gray'))
    
    plt.tight_layout()
    return fig

def plot_enhanced_discrete_wafer_map(x, y, z, grid_size=None, title="Enhanced Discrete Wafer Map", figsize=(12, 10)):
    """绘制增强版离散网格wafer map"""
    fig, ax = plt.subplots(1, 1, figsize=figsize)
    
    if grid_size is None:
        # 智能计算网格大小
        data_density = len(x) / ((x.max() - x.min()) * (y.max() - y.min()))
        grid_size = min(max(int(np.sqrt(len(x) * 0.8)), 10), 25)
    
    # 创建网格
    x_bins = np.linspace(x.min(), x.max(), grid_size + 1)
    y_bins = np.linspace(y.min(), y.max(), grid_size + 1)
    
    # 计算每个网格的统计值
    grid_data = np.full((grid_size, grid_size), np.nan)
    grid_counts = np.zeros((grid_size, grid_size))
    grid_std = np.full((grid_size, grid_size), np.nan)
    
    for i in range(len(x)):
        x_idx = np.digitize(x[i], x_bins) - 1
        y_idx = np.digitize(y[i], y_bins) - 1
        
        if 0 <= x_idx < grid_size and 0 <= y_idx < grid_size:
            if grid_counts[y_idx, x_idx] == 0:
                grid_data[y_idx, x_idx] = z[i]
                grid_counts[y_idx, x_idx] = 1
            else:
                # 计算运行平均值
                old_mean = grid_data[y_idx, x_idx]
                grid_counts[y_idx, x_idx] += 1
                grid_data[y_idx, x_idx] = old_mean + (z[i] - old_mean) / grid_counts[y_idx, x_idx]
    
    # 创建wafer形状遮罩
    center_x = grid_size / 2
    center_y = grid_size / 2
    radius = grid_size / 2 * 0.85  # 稍微缩小以匹配实际形状
    
    # 绘制增强的网格
    for i in range(grid_size):
        for j in range(grid_size):
            # 检查是否在wafer范围内
            dist_to_center = np.sqrt((j - center_x)**2 + (i - center_y)**2)
            if dist_to_center <= radius and not np.isnan(grid_data[i, j]):
                # 计算颜色
                norm_value = (grid_data[i, j] - z.min()) / (z.max() - z.min())
                color = cmap_custom(norm_value)
                
                # 绘制圆角矩形
                rect = patches.FancyBboxPatch((j-0.45, grid_size-1-i-0.45), 0.9, 0.9,
                                            boxstyle="round,pad=0.02",
                                            linewidth=1.2, edgecolor='white', 
                                            facecolor=color, alpha=0.9)
                ax.add_patch(rect)
                
                # 添加数值标签，根据网格大小调整字体
                font_size = max(6, min(10, 120 // grid_size))
                text_color = 'white' if norm_value < 0.5 else 'black'  # 根据背景调整文字颜色
                
                ax.text(j, grid_size-1-i, f'{grid_data[i, j]:.1f}', 
                       ha='center', va='center', fontsize=font_size, 
                       fontweight='bold', color=text_color)
    
    # 设置坐标轴
    ax.set_xlim(-0.7, grid_size - 0.3)
    ax.set_ylim(-0.7, grid_size - 0.3)
    ax.set_aspect('equal')
    
    # 添加网格线
    for i in range(grid_size + 1):
        ax.axhline(i - 0.5, color='gray', linewidth=0.5, alpha=0.3)
        ax.axvline(i - 0.5, color='gray', linewidth=0.5, alpha=0.3)
    
    # 设置刻度
    ax.set_xticks(range(grid_size))
    ax.set_yticks(range(grid_size))
    ax.set_xticklabels([f'{i}' for i in range(grid_size)])
    ax.set_yticklabels([f'{grid_size-1-i}' for i in range(grid_size)])
    
    # 美化标题和标签
    ax.set_title(title, fontsize=16, fontweight='bold', pad=20)
    ax.set_xlabel('X Grid Index', fontsize=12, fontweight='bold')
    ax.set_ylabel('Y Grid Index', fontsize=12, fontweight='bold')
    ax.tick_params(labelsize=10)
    
    # 添加颜色条
    sm = plt.cm.ScalarMappable(cmap=cmap_custom, norm=Normalize(vmin=z.min(), vmax=z.max()))
    sm.set_array([])
    cbar = plt.colorbar(sm, ax=ax, shrink=0.8, pad=0.02)
    cbar.set_label('CD Value (nm)', fontsize=12, fontweight='bold')
    cbar.ax.tick_params(labelsize=10)
    
    plt.tight_layout()
    return fig

def plot_enhanced_comparison(x, y, z, figsize=(20, 9)):
    """绘制增强版对比图"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize)
    
    # === 左图：增强连续性图 ===
    grid_density = 300
    xi = np.linspace(x.min() * 1.05, x.max() * 1.05, grid_density)
    yi = np.linspace(y.min() * 1.05, y.max() * 1.05, grid_density)
    Xi, Yi = np.meshgrid(xi, yi)
    
    # 高质量插值
    Zi = advanced_interpolation(x, y, z, Xi, Yi, method='multi')
    Zi_smooth = gaussian_filter(Zi, sigma=0.8)
    
    # wafer遮罩
    mask, center_x, center_y, radius = create_enhanced_wafer_mask(Xi, Yi, x, y)
    Zi_masked = np.where(mask > 0.1, Zi_smooth, np.nan)
    
    # 绘制
    z_min, z_max = np.nanmin(z), np.nanmax(z)
    levels = np.linspace(z_min, z_max, 80)
    
    contour1 = ax1.contourf(Xi, Yi, Zi_masked, levels=levels, cmap=cmap_custom, extend='both')
    ax1.contour(Xi, Yi, Zi_masked, levels=25, colors='black', alpha=0.1, linewidths=0.3)
    ax1.scatter(x, y, c=z, s=20, cmap=cmap_custom, edgecolors='white', 
               linewidth=0.6, alpha=0.9, zorder=5)
    
    circle1 = plt.Circle((center_x, center_y), radius, fill=False, 
                        color='black', linewidth=2, alpha=0.8)
    ax1.add_patch(circle1)
    
    margin = max((x.max() - x.min()), (y.max() - y.min())) * 0.03
    ax1.set_xlim(x.min() - margin, x.max() + margin)
    ax1.set_ylim(y.min() - margin, y.max() + margin)
    ax1.set_aspect('equal')
    ax1.set_title('Enhanced Continuous Wafer Map', fontsize=14, fontweight='bold')
    ax1.grid(True, alpha=0.2, linestyle='--')
    ax1.set_xlabel('Location X (mm)', fontsize=11)
    ax1.set_ylabel('Location Y (mm)', fontsize=11)
    
    # === 右图：增强离散图 ===
    grid_size = 16
    x_bins = np.linspace(x.min(), x.max(), grid_size + 1)
    y_bins = np.linspace(y.min(), y.max(), grid_size + 1)
    
    grid_data = np.full((grid_size, grid_size), np.nan)
    grid_counts = np.zeros((grid_size, grid_size))
    
    for i in range(len(x)):
        x_idx = np.digitize(x[i], x_bins) - 1
        y_idx = np.digitize(y[i], y_bins) - 1
        if 0 <= x_idx < grid_size and 0 <= y_idx < grid_size:
            if grid_counts[y_idx, x_idx] == 0:
                grid_data[y_idx, x_idx] = z[i]
                grid_counts[y_idx, x_idx] = 1
            else:
                old_mean = grid_data[y_idx, x_idx]
                grid_counts[y_idx, x_idx] += 1
                grid_data[y_idx, x_idx] = old_mean + (z[i] - old_mean) / grid_counts[y_idx, x_idx]
    
    center_x_grid = grid_size / 2
    center_y_grid = grid_size / 2
    radius_grid = grid_size / 2 * 0.85
    
    for i in range(grid_size):
        for j in range(grid_size):
            dist_to_center = np.sqrt((j - center_x_grid)**2 + (i - center_y_grid)**2)
            if dist_to_center <= radius_grid and not np.isnan(grid_data[i, j]):
                norm_value = (grid_data[i, j] - z.min()) / (z.max() - z.min())
                color = cmap_custom(norm_value)
                
                rect = patches.FancyBboxPatch((j-0.45, grid_size-1-i-0.45), 0.9, 0.9,
                                            boxstyle="round,pad=0.02",
                                            linewidth=1, edgecolor='white', 
                                            facecolor=color, alpha=0.9)
                ax2.add_patch(rect)
                
                text_color = 'white' if norm_value < 0.5 else 'black'
                ax2.text(j, grid_size-1-i, f'{grid_data[i, j]:.0f}', 
                        ha='center', va='center', fontsize=8, 
                        fontweight='bold', color=text_color)
    
    ax2.set_xlim(-0.7, grid_size - 0.3)
    ax2.set_ylim(-0.7, grid_size - 0.3)
    ax2.set_aspect('equal')
    ax2.set_title('Enhanced Discrete Wafer Map', fontsize=14, fontweight='bold')
    
    for i in range(grid_size + 1):
        ax2.axhline(i - 0.5, color='gray', linewidth=0.3, alpha=0.4)
        ax2.axvline(i - 0.5, color='gray', linewidth=0.3, alpha=0.4)
    
    ax2.set_xlabel('X Grid Index', fontsize=11)
    ax2.set_ylabel('Y Grid Index', fontsize=11)
    
    # 共享颜色条
    cbar = fig.colorbar(contour1, ax=[ax1, ax2], shrink=0.8, pad=0.08)
    cbar.set_label('CD Value (nm)', fontsize=12, fontweight='bold')
    cbar.ax.tick_params(labelsize=10)
    
    plt.tight_layout()
    return fig

def analyze_enhanced_wafer_data(csv_file_path):
    """完整的增强wafer数据分析和可视化"""
    print("=== 增强版 Wafer Map 分析 ===\n")
    
    # 加载数据
    x, y, z = load_wafer_data(csv_file_path)
    if x is None:
        print("无法加载数据，请检查文件路径和格式")
        return
    
    # 显示详细统计
    print("\n=== 详细数据统计 ===")
    print(f"数据点数量: {len(x)}")
    print(f"CD统计:")
    print(f"  平均值: {np.mean(z):.3f} nm")
    print(f"  中位数: {np.median(z):.3f} nm")
    print(f"  标准差: {np.std(z):.3f} nm")
    print(f"  范围: {z.min():.3f} - {z.max():.3f} nm")
    print(f"  3σ范围: {np.mean(z) - 3*np.std(z):.3f} - {np.mean(z) + 3*np.std(z):.3f} nm")
    print(f"坐标范围:")
    print(f"  X: {x.min():.2f} - {x.max():.2f} mm")
    print(f"  Y: {y.min():.2f} - {y.max():.2f} mm")
    
    # 生成增强版可视化
    print("\n正在生成增强版可视化图表...")
    
    # 增强连续性图
    fig1 = plot_enhanced_continuous_wafer_map(x, y, z, "System-Quality Continuous Wafer Map")
    plt.show()
    
    # 增强离散图
    fig2 = plot_enhanced_discrete_wafer_map(x, y, z, title="System-Quality Discrete Wafer Map")
    plt.show()
    
    # 增强对比图
    fig3 = plot_enhanced_comparison(x, y, z)
    plt.show()
    
    return x, y, z

# 使用示例
if __name__ == "__main__":
    # 请将此路径替换为您的CSV文件路径
    csv_file_path = "your_wafer_data.csv"
    
    try:
        x, y, z = analyze_enhanced_wafer_data(csv_file_path)
    except FileNotFoundError:
        print("请将 'your_wafer_data.csv' 替换为您的实际CSV文件路径")
        
        # 创建更真实的示例数据
        print("正在创建高质量示例数据进行演示...")
        
        np.random.seed(42)
        # 模拟真实wafer数据分布
        n_points = 150
        theta = np.random.uniform(0, 2*np.pi, n_points)
        r = np.sqrt(np.random.uniform(0, 1, n_points)) * 75  # 更均匀的径向分布
        
        x_demo = r * np.cos(theta)
        y_demo = r * np.sin(theta)
        
        # 创建更复杂的CD模式
        z_demo = (420 + 
                 30 * np.sin(2*theta) +  # 角度变化
                 20 * (r/75)**2 +        # 径向变化
                 15 * np.sin(4*theta) +  # 高频角度变化
                 np.random.normal(0, 8, n_points))  # 噪声
        
        print("高质量示例数据演示：")
        fig1 = plot_enhanced_continuous_wafer_map(x_demo, y_demo, z_demo, 
                                                 "示例 - System-Quality Continuous Map")
        plt.show()
        
        fig2 = plot_enhanced_discrete_wafer_map(x_demo, y_demo, z_demo, 
                                               title="示例 - System-Quality Discrete Map")
        plt.show()

# 快速使用函数
def quick_enhanced_wafer_plot(csv_file_path, plot_type='comparison'):
    """快速生成增强版wafer map"""
    x, y, z = load_wafer_data(csv_file_path)
    if x is None:
        return None
    
    if plot_type == 'continuous':
        return plot_enhanced_continuous_wafer_map(x, y, z)
    elif plot_type == 'discrete':
        return plot_enhanced_discrete_wafer_map(x, y, z)
    else:
        return plot_enhanced_comparison(x, y, z)
